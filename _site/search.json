[
  {
    "objectID": "wednesday/index.html",
    "href": "wednesday/index.html",
    "title": "Python for the humanities",
    "section": "",
    "text": "Time:\n9am–noon\nInstructor:\nTannia Chevez (ACENET)\nLive notes:\nEtherpad\nMaterials:\nSlides\nDownload the Jupyter notebook for this morning:  Download \nYou will open this notebook on your computer and work in it.\nYou can see (but not edit) the content of the notebook here.\nAfter the end of today’s class, we will publish a completed notebook at the link above so that you don’t have to worry about missing something during the class: just focus on learning.\nTopic:\nWe will gather internet data using APIs."
  },
  {
    "objectID": "wednesday/index.html#api-querying",
    "href": "wednesday/index.html#api-querying",
    "title": "Python for the humanities",
    "section": "",
    "text": "Time:\n9am–noon\nInstructor:\nTannia Chevez (ACENET)\nLive notes:\nEtherpad\nMaterials:\nSlides\nDownload the Jupyter notebook for this morning:  Download \nYou will open this notebook on your computer and work in it.\nYou can see (but not edit) the content of the notebook here.\nAfter the end of today’s class, we will publish a completed notebook at the link above so that you don’t have to worry about missing something during the class: just focus on learning.\nTopic:\nWe will gather internet data using APIs."
  },
  {
    "objectID": "wednesday/index.html#webscraping-with-ai",
    "href": "wednesday/index.html#webscraping-with-ai",
    "title": "Python for the humanities",
    "section": "Webscraping with AI",
    "text": "Webscraping with AI\n\nTime:\n1:30pm–4:00pm\nInstructor:\nMarie-Hélène Burle (Simon Fraser University)\nLive notes:\nEtherpad\nMaterial:\nWebsite\nTopic:\nYesterday we saw how useful LLMs can be to write simple snippets of code and learn a new programming language. Today, we will try to do something a lot more complex with the help of an LLM: write a program to scrape a website."
  },
  {
    "objectID": "tuesday/day2_morning.html",
    "href": "tuesday/day2_morning.html",
    "title": "Introductory Programming with Python",
    "section": "",
    "text": "Before we jump into analyzing data, let’s talk about one of the most powerful tools in programming: variables. Think of a variable like a storage box where you can put information that you might want to use later. This is how we make computers remember things for us!\nLet’s start with something simple. Imagine using Python like a calculator. You can do quick math, like this:\n\n#your code goes here\n\nThis is very handy, but let’s be honest, it’s not very exciting. What makes programming powerful is the ability to store this result or any other data, and use it again whenever we need it. That’s where variables come in.\n\n\nA variable is a name that refers to a value. In the previous example, we saw that we can use Python as an advanced calculator. However, the results of these computations are lost after we perform our operations. If we want to save and reuse any value in a code, we need to save these computations in a place in computer memory to be able to access it in the future.\nVariables are names that we associate with a memory location in computers. As such variables are not values themselves but they point to a memory location where the actual values are stored.\n\n#your code goes here\n\nNow, Python will remember that weight_kg equals 60. Instead of doing the math all over again or writing the number repeatedly, we just use weight_kg whenever we need it.\nA Few Rules for Naming Variables: - You can use letters, digits, and **underscores (_), but the name can’t** start with a digit. - Variable names are case-sensitive, so weight and Weight are two different things.\nFor example: - weight0 is valid, but 0weight isn’t. - weight_kg is different from Weight_kg.\n\n\n\nPython can work with different types of data. Three of the most common types are:\n\nIntegers (whole numbers like 1, 2, 100)\nFloating point numbers (numbers with decimals like 2.5, 60.3)\nStrings (text like “Hello”, “001”)\nBooleans (True or False)\n\nFor example, let’s say we want to store a patient’s weight. If the weight is exactly 60 kilograms, we can use an integer:\n\n#your code goes here\n\nBut if we want to be more precise, like 60.3 kilograms, we can use a floating point number:\n\n#your code goes here\n\nHere, weight_kg is a variable that stores a decimal number, or a float. It could represent any weight in kg measurement, which we might later use for calculations or comparisons.\nWe can also store text:\n\n#your code goes here\n\nStrings can store text data, which can be useful for labeling or adding metadata.\nAnd lastly, we have booleans, which are used to represent true or false values. They are helpful in logical operations or conditions:\n\n#your code goes here\n\nWith this variable, we could decide whether to apply certain calculations or adjustments based on the height. It can help us write cleaner, more conditional code."
  },
  {
    "objectID": "tuesday/day2_morning.html#variables",
    "href": "tuesday/day2_morning.html#variables",
    "title": "Introductory Programming with Python",
    "section": "",
    "text": "Before we jump into analyzing data, let’s talk about one of the most powerful tools in programming: variables. Think of a variable like a storage box where you can put information that you might want to use later. This is how we make computers remember things for us!\nLet’s start with something simple. Imagine using Python like a calculator. You can do quick math, like this:\n\n#your code goes here\n\nThis is very handy, but let’s be honest, it’s not very exciting. What makes programming powerful is the ability to store this result or any other data, and use it again whenever we need it. That’s where variables come in.\n\n\nA variable is a name that refers to a value. In the previous example, we saw that we can use Python as an advanced calculator. However, the results of these computations are lost after we perform our operations. If we want to save and reuse any value in a code, we need to save these computations in a place in computer memory to be able to access it in the future.\nVariables are names that we associate with a memory location in computers. As such variables are not values themselves but they point to a memory location where the actual values are stored.\n\n#your code goes here\n\nNow, Python will remember that weight_kg equals 60. Instead of doing the math all over again or writing the number repeatedly, we just use weight_kg whenever we need it.\nA Few Rules for Naming Variables: - You can use letters, digits, and **underscores (_), but the name can’t** start with a digit. - Variable names are case-sensitive, so weight and Weight are two different things.\nFor example: - weight0 is valid, but 0weight isn’t. - weight_kg is different from Weight_kg.\n\n\n\nPython can work with different types of data. Three of the most common types are:\n\nIntegers (whole numbers like 1, 2, 100)\nFloating point numbers (numbers with decimals like 2.5, 60.3)\nStrings (text like “Hello”, “001”)\nBooleans (True or False)\n\nFor example, let’s say we want to store a patient’s weight. If the weight is exactly 60 kilograms, we can use an integer:\n\n#your code goes here\n\nBut if we want to be more precise, like 60.3 kilograms, we can use a floating point number:\n\n#your code goes here\n\nHere, weight_kg is a variable that stores a decimal number, or a float. It could represent any weight in kg measurement, which we might later use for calculations or comparisons.\nWe can also store text:\n\n#your code goes here\n\nStrings can store text data, which can be useful for labeling or adding metadata.\nAnd lastly, we have booleans, which are used to represent true or false values. They are helpful in logical operations or conditions:\n\n#your code goes here\n\nWith this variable, we could decide whether to apply certain calculations or adjustments based on the height. It can help us write cleaner, more conditional code."
  },
  {
    "objectID": "tuesday/day2_morning.html#basic-operations-with-variables",
    "href": "tuesday/day2_morning.html#basic-operations-with-variables",
    "title": "Introductory Programming with Python",
    "section": "Basic Operations with Variables",
    "text": "Basic Operations with Variables\n\nWorking with Numbers: Integers and Floats\nAddition is one of the simplest operations. If you want to increase a value, you just add to it. For example, if you have a population measurement of 20000 and want to add 5000 more, Python gives you a new population number of 25000 like this:\n\n#your code goes here\n\nOther operations are just as simple. If you want to double a temperature value, you multiply it by 2 like this:\n\n#your code goes here\n\nDivision also works the same way: dividing 20000 by 100 gives 200.0 like this:\n\n#your code goes here\n\nPython can also handle exponents, like squaring numbers. If you want to find what 20000 times 20000 is, you can get it this way:\n\n#your code goes here\n\nThis is useful for calculating things like squared distances or other exponential relationships.\n### Exercise 1: You are studying urban growth in a geography class. City A had a population of 1,500,000 people in the year 2000, and it grew to 2,100,000 people by the year 2020.\nYour task is to write a Python program that: - Stores the population values in variables. - Calculates how much the population has grown. - Displays the result using print().\n\n#your code goes here\n\n\n\nWorking with Strings\nWith strings, one common thing we do is combine them, known as concatenation. Imagine you have two words, first name and last name, like “John” and “Doe”, and you want to make them into one full name: “John Doe.” You do this by placing them side by side with a plus sign between them, and Python combines them into one.\n\n#your code goes here\n\nAnother thing you can do with strings is repeat them. For instance, if you have the word “hello,” you could repeat it multiple times, like “hello hello hello” In Python, you simply tell it to multiply the word by the number of times you want it to appear like this:\n\n#your code goes here\n\n\n\nWorking with Booleans\nBooleans in Python are very straightforward: they represent only two options, True or False. They’re useful when you’re asking questions or checking if something meets certain conditions.\nFor example, let’s say you want to check if a town’s population is above a certain number. Imagine the town has a population of 20,000 people, and you want to know if it’s larger than 10,000:\n\n#your code goes here\n\nWe can also ask Python to check multiple conditions at once. Maybe you want to know if a town has both a large population (over 10,000 people) and a low unemployment rate (under 5%). You can combine these two questions into one. If both are true, Python returns True; if either one isn’t, it returns False.\n\n#your code goes here\n\n\n\nMixing Types Together\nSometimes, Python lets us mix different types in ways that make sense. For example, in Python, True is treated as 1 and False as 0. So if you’re working with a number and a condition, Python might add 1 if the condition is True, or add nothing if it’s False. This can be handy for quick adjustments, like slightly increasing a value if a condition is met.\n\n#your code goes here\n\nThese simple operations let you do quite a bit in Python. With strings, you can create descriptive phrases; with numbers, you can add, multiply, and do more complex math; with booleans, you can check conditions and make decisions. This flexibility is what makes Python both powerful and beginner-friendly—it’s easy to write code that mimics real-world problem-solving, step by step."
  },
  {
    "objectID": "tuesday/day2_morning.html#data-structures",
    "href": "tuesday/day2_morning.html#data-structures",
    "title": "Introductory Programming with Python",
    "section": "Data Structures",
    "text": "Data Structures\nData structures are essential for organizing and managing data in programming. In Python, we have several types of data structures, but three of the most commonly used ones are lists, tuples, and dictionaries. Each of these has unique characteristics and uses that make them suitable for different tasks.\n\nLists\nA list in Python is a collection of items that can be modified. This means you can add, remove, or change items in a list as needed. Lists are defined using square brackets []:\n\n#your code goes here  \n\nIn this example, we have a list called grades that stores test scores from different students.\n\nUsing Lists:\n1. Accessing Lists: Each item in a list has a position called an index, starting from 0. You can access any item using its index:\n\n#your code goes here\n\n2. Modifying Items: Lists are mutable, meaning you can change their contents:\n\n#your code goes here\n\n3. Adding Items: You can add new items to the end of a list using the append() method:\n\n#your code goes here\n\n4. Removing Items: You can remove items from a list using the remove() method or the pop() method:\n\n#your code goes here\n\n\n#your code goes here\n\nConsider a scenario where you are recording student test scores for a class. You can store these scores in a list. As new test results come in, you can easily update the list by adding new scores or modifying existing ones.\n\n\n\nExercise 2\n\nCreate a list named philosophers that contains these names as strings: “Plato”, “Aristotle”, “Confucius”, and “Socrates”.\nAdd the philosopher “Descartes” to the end of the list.\nRemove “Confucius” from the list.\nPrint the updated list to see the changes.\n\n\n#your code goes here\n\n\n\nTuples\nA tuple is a collection of items, similar to a list, but it is immutable. This means that once a tuple is created, it cannot be changed. Tuples are defined using parentheses ().\n\n#your code goes here\n\nThis tuple represents the geographic coordinates of a specific location.\n\nUsing Tuples:\n1. Accessing Items: Just like lists, you can access items in a tuple using their index:\n\n#your code goes here\n\n\n#your code goes here\n\n2. Benefits of Immutability: Since tuples cannot be changed, they are useful for storing fixed data that should not be altered. This can help prevent accidental changes to important values.\nIn oceanography, you might want to store the coordinates of a specific research station. Since these coordinates are fixed and won’t change, a tuple is the ideal choice. If you need to reference these coordinates later in your code, you can do so confidently, knowing they will not change.\n\n\n\nDictionaries\nA dictionary in Python is a collection of key-value pairs, similar to how a real dictionary has words (keys) and their meanings (values). Each key in a dictionary must be unique, and you can use it to access its corresponding value. Dictionaries are defined using curly braces {}.\n\n#your code goes here\n\nIn this example, we have a dictionary called student_data that stores various pieces of information about a student’s academic details.\n\nUsing Dictionaries:\n1. Accessing Values: You can retrieve a value using its corresponding key.\n\n#your code goes here \n\n2. Adding or Modifying Values: You can easily add new key-value pairs or modify existing ones:\n\n#Modify Existing one\n#your code goes here \n\n\n#Adding new key-value pair\n#your code goes here \n\n3. Removing Key-Value Pairs: You can remove a key-value pair using the del statement:\n\n#your code goes here\n\n\n\n\nExercise 3\n\nCreate a dictionary named countries with these key-value pairs:\n\n\n“United States” : “English”\n“Mexico” : “Spanish”\n“France” : “French”\n“Canada” : “English and French”\n\n\nAdd a new entry to the dictionary: “Brazil” : “Portuguese”\nRemove the key “France” and its value using the del statement.\nPrint the updated dictionary every time.\n\n\n#your code goes here\n\n\nChoosing the Right Data Structure\nSelecting the appropriate data structure is crucial. Here’s a quick guide:\n\nUse Lists when you need to store a collection of items that you might want to change or add to, like student grades over multiple subjects or assignments.\nUse Tuples for fixed data points that won’t change, such as geographic coordinates of research locations.\nUse Dictionaries when you need to associate related information together, such as all academic details for a specific student.\n\nChoosing the right data structure will make your data management more efficient and your code easier to understand."
  },
  {
    "objectID": "tuesday/day2_morning.html#control-structures",
    "href": "tuesday/day2_morning.html#control-structures",
    "title": "Introductory Programming with Python",
    "section": "Control Structures",
    "text": "Control Structures\nControl structures are essential programming constructs that allow us to dictate the flow of our program. In Python, the most commonly used control structures include loops (for and while) and conditionals (if and else). These structures enable us to repeat actions, make decisions based on conditions, and manage how we process data.\n\nConditionals\nConditionals allow us to execute certain blocks of code based on specific conditions. This means that our program can make decisions and act differently depending on the situation. The most common conditional statements in Python are if, elif, and else.\n\nBasic Structure of Conditionals:\nHere’s a simple structure for using conditionals:\nif condition: # Code to execute if the condition is true elif another_condition: # Code to execute if the first condition is false and this one is true else: # Code to execute if both conditions are false\n\n\nComparison Operators\nComparison operators allow us to compare two values. Here are the most commonly used comparison operators in Python:\n==: Equal to (checks if two values are the same) !=: Not equal to (checks if two values are different) &gt;: Greater than (checks if the left value is larger than the right) &lt;: Less than (checks if the left value is smaller than the right) &gt;=: Greater than or equal to (checks if the left value is larger than or equal to the right) &lt;=: Less than or equal to (checks if the left value is smaller than or equal to the right)\nLet’s say we want to categorize towns based on their population size:\n\n#your code goes here\n\nIn this example:\n\nIf the population is less than 5,000, it prints “Small town.”\nIf the population is between 5,000 and 20,000 (inclusive), it prints “Medium-sized town.”\nIf the population is over 20,000, it prints “Large town.”\n\n\n\nLogical Operators\nLogical operators allow us to combine multiple conditions. The most commonly used logical operators are:\n\nand: Returns True if both conditions are true.\nor: Returns True if at least one condition is true.\nnot: Reverses the truth value (makes True become False and vice versa).\n\nLet’s say we want to check if someone’s annual income falls within the middle-income bracket:\n\n#your code goes here\n\nIn this example:\n\nThe condition annual_income &gt;= 30000 and annual_income &lt;= 70000 checks if the income is between 30,000 and 70,000 inclusive.\nIf both are true, it prints “Middle-income bracket.”\n\n\n\n\nLoops\nLoops allow us to repeat a block of code multiple times. This is especially useful when we have to process a collection of items, like a list of temperature readings or salinity measurements. The two primary types of loops in Python are for loops and while loops.\n\nFor Loops:\nA for loop is used to iterate over a sequence (like a list or a tuple). Here’s the basic structure:\nfor item in sequence: # Code to execute for each item\nLet’s say we want to print out each survey response score from a list:\n\n#your code goes here\n\nIn this example, the loop goes through each item in the survey_scores list and prints it.\nFor loops are useful for analyzing data, such as calculating the average monthly income from several months:\n\nmonthly_incomes = [3000, 3200, 3100, 2900, 4000, 3500, 2500, 2900, 3050, 3200, 3500, 2950]\n#your code goes here\n\nIn this case, the loop adds up all the monthly incomes and then finds the average by dividing by the number of months.\n\n\n\nExercise 4\n\nYou are given a list named populations that contains population numbers (in thousands).\nUse a for loop to add all the population numbers together and store the total in a variable called total_population.\nCalculate the average population by dividing the total population.\nPrint the average population rounded to the nearest whole number.\n\n\npopulations = [2731, 631, 1135, 934, 1705]\n\n#your code goes here\n\n\nWhile Loops\nA while loop continues to execute as long as a specified condition is true. The basic structure looks like this:\nwhile condition: # Code to execute while the condition is true\nLet’s say we want to keep recording monthly expenses until we have data for five months:\n\n#your code goes here\n\nIn this example, the loop keeps asking for monthly expenses until it has collected five amounts.\nWhile loops are useful for continuous data collection, like tracking monthly donations until reaching a target amount:\n\n#your code goes here\n\n\n\n\nCombining Loops and Conditionals\nOften, we will need to use both loops and conditionals together to process data effectively. For example, you might want to analyze temperature readings and categorize them within a loop.\nLet’s categorize a list of temperature readings as “Cold,” “Warm,” or “Hot”:\n\n#your code goes here\n\nIn this example, the loop goes through each temperature reading, and the conditional statements categorize each temperature accordingly.\nNow, let’s say we want to use a loop to analyze data stored in a dictionary. We have a dictionary of historical events and the years they happened. Using a for loop, we can go through each event and year, and use a control structure like an if statement to check whether the event happened before or after 1900.\n\n#your code goes here\n\n\n\nExercise 5\nYou are given a dictionary of universities worldwide with their average graduation rates (in percentages):\nuniversities = { “Harvard University”: 98,\n\"University of Oxford\": 92,\n\n\"Stanford University\": 94,\n\n\"Massachusetts Institute of Technology (MIT)\": 92,\n\n\"University of Cambridge\": 93,\n\n\"University of Tokyo\": 70,\n\n\"University of Melbourne\": 79,\n\n\"University of Cape Town\": 68,\n\n\"University of São Paulo\": 65,\n\n\"National University of Singapore\": 80\n}\nTask:\n\nLoop through each university and its graduation rate.\nPrint the university name and its graduation rate.\nUse conditional statements to classify the graduation rate:\n\n90% or above: print “Excellent graduation rate”.\nBetween 75% and 89% (inclusive): print “Good graduation rate”.\nBelow 75%: print “Needs improvement”.\n\n\n\n#your code goes here"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#computer-programming",
    "href": "monday/wb_hss_prog_slides.html#computer-programming",
    "title": "Intro programming for the humanities",
    "section": "Computer programming",
    "text": "Computer programming\nProgramming (or coding) consists of writing a set of instructions (a program) for computers so that they perform a task\nThere are many programming languages—each with its own syntax—but the core concepts apply to all languages. For this course, we will use Python\nPrograms accept inputs (data) and produce outputs (transformed data)"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#important-considerations",
    "href": "monday/wb_hss_prog_slides.html#important-considerations",
    "title": "Intro programming for the humanities",
    "section": "Important considerations",
    "text": "Important considerations\n\nFree and open source software (FOSS) vs proprietary\nCompiled vs interpreted language (speed vs convenience)\nLanguage adapted to particular usage\nLanguage used in your field (colleagues, collaborators, literature)"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#downsides-of-proprietary-software",
    "href": "monday/wb_hss_prog_slides.html#downsides-of-proprietary-software",
    "title": "Intro programming for the humanities",
    "section": "Downsides of proprietary software",
    "text": "Downsides of proprietary software\n\nResearchers who do not have access to the tool cannot reproduce your methods\nOnce you leave academia, you may not have access to the tool anymore\nYour university may stop paying for a license\nYou may get locked-in\nProprietary tools are black boxes\nLong-term access is uncertain\nProprietary tools fall behind popular open-source tools\nProprietary tools often fail to address specialized edge cases needed in research"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#the-argument-for-foss",
    "href": "monday/wb_hss_prog_slides.html#the-argument-for-foss",
    "title": "Intro programming for the humanities",
    "section": "The argument for FOSS",
    "text": "The argument for FOSS\n\nEqual access to everyone, including poorer countries or organizations (it’s free!)\nOpen science\nTransparency\nThe whole community can contribute to and have a say about development\nYou an build specific capabilities for your edge cases\nGuarantied long term access\nNo risk of getting locked-in"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#compiled-languages",
    "href": "monday/wb_hss_prog_slides.html#compiled-languages",
    "title": "Intro programming for the humanities",
    "section": "Compiled languages",
    "text": "Compiled languages\nYou write code, compile it into machine code, then use this to process your data\n\nCompiled languages are fast. The two step process however makes prototyping less practical and these languages are hard to learn and debug\n\nExamples of compiled languages include C, C++, Fortran, Go, Haskell"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#interpreted-languages",
    "href": "monday/wb_hss_prog_slides.html#interpreted-languages",
    "title": "Intro programming for the humanities",
    "section": "Interpreted languages",
    "text": "Interpreted languages\nInterpreted languages are executed directly\n\nYou get direct feed-back, making it easier to prototype. Interpreted languages are easy to learn and debug, but they are much slower\n\nExamples of interpreted languages include R, Python, Perl, and JavaScript"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#python",
    "href": "monday/wb_hss_prog_slides.html#python",
    "title": "Intro programming for the humanities",
    "section": "Python",
    "text": "Python\nPython is free and open-source, interpreted, and general-purpose\nIt was created by Dutch programmer Guido van Rossum in the 80s, with a launch in 1989\nThe PYPL PopularitY of Programming Language index is based on the number of tutorial searches in Google. Python has been going up steadily, reaching the first position in 2018. It is also ahead in other indices and is the language used by most of the deep learning community\nThis doesn’t mean that Python is better than other languages, but it means that there are a lot of resources and a large collection of external packages"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#text-editor-to-write-scripts",
    "href": "monday/wb_hss_prog_slides.html#text-editor-to-write-scripts",
    "title": "Intro programming for the humanities",
    "section": "Text editor to write scripts",
    "text": "Text editor to write scripts\nA text editor is not the same as a word processor such as Microsoft Office Word. Word documents are not plain text documents: they contain a lot of hidden formatting and are actually a collection of files. This is not what you want to write scripts\nExamples of good text editors (free and open source):\n\nEmacs\nVisual Studio Code\nVim"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#optional-an-ide",
    "href": "monday/wb_hss_prog_slides.html#optional-an-ide",
    "title": "Intro programming for the humanities",
    "section": "Optional: an IDE",
    "text": "Optional: an IDE\nIntegrated development environments (IDEs) are software that make running a language more friendly by adding functionality and convenience tools, usually within a graphical user interface (GUI)\nA popular IDE for Python is JupyterLab"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#debugging-and-profiling-tools",
    "href": "monday/wb_hss_prog_slides.html#debugging-and-profiling-tools",
    "title": "Intro programming for the humanities",
    "section": "Debugging and profiling tools",
    "text": "Debugging and profiling tools\nSome languages come with debugging tools that make it easier to find problems in the code\nProfilers allow you to spot bottlenecks in the execution of your code\nBenchmarking tools allow you to compare several versions of code to find which is faster"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#hardware",
    "href": "monday/wb_hss_prog_slides.html#hardware",
    "title": "Intro programming for the humanities",
    "section": "Hardware",
    "text": "Hardware\nPython is great in many respects, but it is not a fast language\nMany libraries for Python are written in faster compiled languages (e.g. C, C++, Fortran)\nTo speed things up more, some code or sections of code can be run in parallel (instead of serially). To do this though, you need more hardware\nYou can run code using multiple CPUs (central processing unit). Some code can be accelerated using GPUs (graphical processing unit)\nFor very large scale projects such as very large simulations, deep learning, or big data projects, you can use supercomputers"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#python-shell",
    "href": "monday/wb_hss_prog_slides.html#python-shell",
    "title": "Intro programming for the humanities",
    "section": "Python shell",
    "text": "Python shell\nThe simplest way to use Python is to type commands directly in the Python shell. This sends commands directly to the interpreter\nThe Python shell has a prompt that looks like this:\n&gt;&gt;&gt;"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#ipython",
    "href": "monday/wb_hss_prog_slides.html#ipython",
    "title": "Intro programming for the humanities",
    "section": "IPython",
    "text": "IPython\nIPython is an improved shell with better performance and more functionality (e.g. colour-coding, magic commands)\nThe prompt looks like:\nIn [x]:\n\nx is the command number (e.g. for your first command, it will show In [1]:"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#jupyter",
    "href": "monday/wb_hss_prog_slides.html#jupyter",
    "title": "Intro programming for the humanities",
    "section": "Jupyter",
    "text": "Jupyter\nThe IPython shell was integrated into a fancy interface, the Jupyter notebook. This later lead to a fully fledged IDE (integrated development environment) called JupyterLab which contains notebooks, a command line, a file explorer, and other functionality\n\nEven though JupyterLab runs in your browser, it does not use the internet: it is all run locally on your machine (browsers are software that are great at displaying HTML files, so we use them to access the web, but they can also display files from your computer)"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#other-ides",
    "href": "monday/wb_hss_prog_slides.html#other-ides",
    "title": "Intro programming for the humanities",
    "section": "Other IDEs",
    "text": "Other IDEs\nJupyter has probably become the most popular IDE, but it is possible to run Python in other IDE such as Emacs"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#python-script",
    "href": "monday/wb_hss_prog_slides.html#python-script",
    "title": "Intro programming for the humanities",
    "section": "Python script",
    "text": "Python script\nYou can write your Python code in a text file with a .py extension and run the script in your terminal with:\npython script.py\nThis will execute the code non-interactively"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#packages",
    "href": "monday/wb_hss_prog_slides.html#packages",
    "title": "Intro programming for the humanities",
    "section": "Packages",
    "text": "Packages\nMany languages can have their functionality expanded by the installation of packages developed by the open source community. The potential is unlimited\nMany languages come with their own package manager\nIn Python, popular package managers include pip, Conda, and the newer much faster uv"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#syntax",
    "href": "monday/wb_hss_prog_slides.html#syntax",
    "title": "Intro programming for the humanities",
    "section": "Syntax",
    "text": "Syntax\nEach language uses its own syntax\n\nExample:\nIn Python, the tab (equal to four spaces by default) has meaning, while in R, it doesn’t (it only makes it easier for people to read code)"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#data-types",
    "href": "monday/wb_hss_prog_slides.html#data-types",
    "title": "Intro programming for the humanities",
    "section": "Data types",
    "text": "Data types\nEach language contains various data types such as integers, floating-point numbers (decimals), strings (series of characters), Booleans (true/false), etc.\n\nPython examples:\n\n\ntype(5)\n\nint\n\n\n\ntype(5.0)\n\nfloat\n\n\n\ntype(\"This is a string\")\n\nstr\n\n\n\ntype(True)\n\nbool"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#variables",
    "href": "monday/wb_hss_prog_slides.html#variables",
    "title": "Intro programming for the humanities",
    "section": "Variables",
    "text": "Variables\nValues can be assigned to names to create variables\n\nPython example\n\n\na = 3\n\na is now a variable containing the value 3:\n\nprint(a)\n\n3\n\n\n\na * 2\n\n6"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#data-structures",
    "href": "monday/wb_hss_prog_slides.html#data-structures",
    "title": "Intro programming for the humanities",
    "section": "Data structures",
    "text": "Data structures\nA data structure is a collection of values\n\nPython examples:\n\n\ntype([0, 5, \"something\"])\n\nlist\n\n\n\ntype((3, 5, \"something\"))\n\ntuple\n\n\n\ntype({0, 2, 6})\n\nset\n\n\nEach type of structure has its own characteristics (necessarily homogeneous or not, mutable or not, ordered or not, etc.). This gives several data storage options, each best in different situations"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#functions",
    "href": "monday/wb_hss_prog_slides.html#functions",
    "title": "Intro programming for the humanities",
    "section": "Functions",
    "text": "Functions\nFunctions are snippets of code that accomplish a specific task\nBuilt-in functions come with the language and are readily available. Other functions become available once a particular module or package is loaded. Finally, the user can definite their own functions\nSome functions take arguments\n\nPython examples:\n\n\nmax([3, 5, 2])\n\n5\n\n\n\ndef hello():\n    print(\"Hello everyone!\")\n\nhello()\n\nHello everyone!"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#control-flow",
    "href": "monday/wb_hss_prog_slides.html#control-flow",
    "title": "Intro programming for the humanities",
    "section": "Control flow",
    "text": "Control flow\nCommands are normally run sequentially, from top to bottom, but it is possible to alter the flow of execution by creating repeats (loops) or conditional executions\n\nPython examples:\n\n\nfor i in range(3):\n    print(i)\n\n0\n1\n2\n\n\n\nx = -3\n\nif x &gt; 0:\n    print(x + 2)\nelse:\n    print(x * 3)\n\n-9"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#internal-documentation",
    "href": "monday/wb_hss_prog_slides.html#internal-documentation",
    "title": "Intro programming for the humanities",
    "section": "Internal documentation",
    "text": "Internal documentation\nMost languages come with their internal documentation\n\nExample with Python:\n\nhelp(sum)\nHelp on built-in function sum in module builtins:\n\nsum(iterable, /, start=0)\n    Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\n    When the iterable is empty, return the start value.\n    This function is intended specifically for use with numeric values and may\n    reject non-numeric types."
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#the-internet",
    "href": "monday/wb_hss_prog_slides.html#the-internet",
    "title": "Intro programming for the humanities",
    "section": "The internet",
    "text": "The internet\nGoogle is often your best bet, but you need to know the vocabulary in order to ask questions\nStack Overflow is a fantastic community question & answer website"
  },
  {
    "objectID": "monday/wb_hss_prog_slides.html#large-language-models-llms",
    "href": "monday/wb_hss_prog_slides.html#large-language-models-llms",
    "title": "Intro programming for the humanities",
    "section": "Large language models (LLMs)",
    "text": "Large language models (LLMs)\nOver the past few years, LLMs have become increasingly performant at coding\nPeople use them in different ways:\n\nAsk questions (explain code, documentation)\nAuto-completion\nFirst code draft\nDebugging\nVibe coding\n\nIn this course, I will show you how they can help you write code"
  },
  {
    "objectID": "monday/day1_afternoon.html",
    "href": "monday/day1_afternoon.html",
    "title": "Introduction to Python for Digital Humanities",
    "section": "",
    "text": "The Digital Humanities (DH) is an interdisciplinary field that brings together computational tools and methods with traditional disciplines in the humanities, such as history, literature, art history, linguistics, philosophy, and cultural studies. As the volume of digital cultural content grows—such as digitized manuscripts, historical records, social media posts, and multimedia archives—the need to process, analyze, and interpret these materials using digital tools becomes increasingly important."
  },
  {
    "objectID": "monday/day1_afternoon.html#introduction-to-jupyterlab",
    "href": "monday/day1_afternoon.html#introduction-to-jupyterlab",
    "title": "Introduction to Python for Digital Humanities",
    "section": "Introduction to JupyterLab",
    "text": "Introduction to JupyterLab\nJupyterLab is an interactive computing environment that allows you to create and share documents containing live code, equations, visualizations, and narrative text. It is commonly used in data science, research, and education, especially for projects in the Digital Humanities, because of its flexibility and ease of use. JupyterLab is essentially an upgrade of Jupyter Notebooks, providing a more modular and feature-rich interface.\n\nKey Features of JupyterLab:\n\nCode cells: These are cells where you write and execute code.\nMarkdown cells: These cells are used for explanatory text, formatted using Markdown.\nRich outputs: Visualizations, graphs, images, and other media can be displayed inline within the notebook.\nFile management: JupyterLab has a built-in file browser that allows you to organize and manage notebooks, text files, images, and other resources.\n\n\n\nHow to Add Cells in JupyterLab\nIn JupyterLab, cells are the building blocks of your notebook. You can add, delete, and modify cells to create a flow between code execution and explanatory text.\n\nAdding Cells:\n\nVia Menu: Navigate to the top menu: Insert → Insert Cell Below or Insert → Insert Cell Above.\nKeyboard Shortcuts: Press B to insert a cell below the current one or A to insert a cell above.\nClicking Buttons: Use the “+” button in the toolbar to insert new cells.\n\n\n\nSwitching Between Cell Types (Code and Markdown):\nYou can switch between code cells and markdown cells to organize your content effectively.\n\nTo Change a Cell Type to Code:\n\n\nSelect the cell and press Y.\nAlternatively, click on the Cell Type dropdown menu in the toolbar (where “Markdown” is by default) and select Code.\n\n\nTo Change a Cell Type to Markdown:\n\n\nSelect the cell and press M.\nAlternatively, use the Cell Type dropdown and select Markdown.\n\nThis allows you to seamlessly switch between running code and writing descriptive text.\n\n\nRunning and Stopping Cells\nCells in JupyterLab can either be run (executed) or stopped, depending on whether you want to see the result of the code.\n\nRunning Cells: To execute a cell, you can:\n\n\nWindows/Linux: Press Shift + Enter to run the current cell and move to the next.\nMac: Press Shift + Enter to run the current cell and move to the next. You can also use command + Enter to run the cell and stay in that cell.\nAlternatively, click the Run button in the toolbar.\n\n\nStopping a Cell: If you want to stop the execution of a cell:\n\n\nNavigate to Kernel → Interrupt in the top menu or use the Stop button in the toolbar.\nAlternatively, use the keyboard shortcut I twice (press I quickly two times) to interrupt the current execution.\n\n\n\n\nThe Kernel in JupyterLab\nThe kernel is the engine behind your notebook, it runs your Python code and remembers what you’ve done.\nWhen you press Shift + Enter to run a cell, the kernel executes that code and gives you a result (a number, a list, a graph, etc.).\n\nUnderstanding [ ], [*], and [1] in Jupyter Cells\nEvery time you run a code cell, you’ll see a number appear inside square brackets next to the cell, like this:\n\n#Your code goes here\n\nHere’s what those brackets mean:\n[ ] — The cell has not been run yet.\n[*] — The code is currently running (kernel is busy).\n[1], [2], … — The number shows the order in which you ran the cells.\nFor example:\nIf you see [5] next to a cell, it means this was the fifth cell you ran.\nIf a cell is stuck on [*], it might be taking a long time or be stuck — you can stop it using Kernel → Interrupt.\n\n\nCommon Kernel Actions:\n\nRun code: Shift + Enter\nInterrupt kernel: Stop a running cell (especially useful if stuck on [*])\nRestart kernel: Clears everything the kernel remembers (variables, imports, etc.)\n\nUse Kernel → Restart if things get messy or confusing — then rerun your cells from the top to start fresh."
  },
  {
    "objectID": "monday/day1_afternoon.html#built-in-functions-and-documentation",
    "href": "monday/day1_afternoon.html#built-in-functions-and-documentation",
    "title": "Introduction to Python for Digital Humanities",
    "section": "Built-in Functions and Documentation",
    "text": "Built-in Functions and Documentation\nPython provides a wide range of built-in functions—these are standard, preloaded tools that help with common tasks. They require no additional libraries or installations and are available immediately when you run Python.\n\nWhat Are Built-in Functions?\nA built-in function is a function that is always available in Python. These are designed to simplify common programming tasks. For instance, rather than writing your own code to calculate the length of a string, you can use len().\nBuilt-in functions improve productivity and reduce the need for writing code from scratch for basic operations.\n\n\nCommon Built-in Functions and What They Do:\n\nprint(): Displays text or variable output.\nlen(): Returns the number of items in an object (string, list, etc.).\ntype(): Returns the data type of a variable (e.g., int, str).\nint(), float(), str(): Convert between data types.\nrange(): Produces a sequence of numbers, often used in loops.\nsum(): Adds numbers in a list or iterable.\nsorted(): Returns a new list containing all items from the iterable in ascending order.\nmax() / min(): Finds the largest or smallest value in a dataset.\n\n\n# Example 1: Basic text output\n#Your code goes here\n\n# Example 2: Working with a string\n#Your code goes here\n\n# Example 3: Check data type\n#Your code goes here\n\n# Example 4: Sorting a list\n#Your code goes here\n\n# Example 5: Using range and sum\n#Your code goes here\n\n\n\nExploring Python Documentation\nLearning how to explore the documentation is key to becoming self-sufficient in Python.\nPython provides tools for this: - help() function - The ? syntax in Jupyter Notebooks\n\n#Your code goes here\n\nThis gives detailed information about how to work with strings.\n\n#Your code goes here\n\nThis brings up a quick help popup describing the str class.\nYou can also combine help with other functions:\n\n#Your code goes here\n\nThis shows how the len() function works and what types it supports."
  },
  {
    "objectID": "monday/day1_afternoon.html#libraries-and-modules",
    "href": "monday/day1_afternoon.html#libraries-and-modules",
    "title": "Introduction to Python for Digital Humanities",
    "section": "Libraries and Modules",
    "text": "Libraries and Modules\nPython’s strength lies in its standard library and external packages—collections of modules that offer specialized functionality. A module is simply a file containing Python definitions and statements. A library is a collection of modules that can be imported and used in your programs.\n\nWhy Libraries Matter:\nThey save time and provide tested, optimized tools for: - Text processing - Data handling - Visualization - Machine learning - File and network operations\n\n\nImporting Modules\nTo use a module, you import it into your Python script:\n\n#Your code goes here\n\nYou can also import specific functions or classes:\n\n#Your code goes here\n\nOr give a library module an alias:\n\n#Your code goes here\n\n\n\nBuilt-in Python Libraries\nPython comes with a rich standard library — a collection of modules and packages that are bundled with Python itself. This means you don’t need to install anything extra to start using them. They’re always available whenever you run Python, making it super convenient to perform many common programming tasks right out of the box.\n\nrandom : Generate random numbers\nUseful for creating random data, games, simulations, or selecting random elements.\n\n#Your code goes here\n\n\n\ndatetime — Work with dates and times\nEasily get the current date/time or perform date calculations.\n\n#Your code goes here\n\n\n\nos — Interact with your computer’s operating system\nGet info about files, directories, environment variables, or execute system commands.\n\n#Your code goes here\n\n\n\n\nExternal Libraries\nWhile Python’s built-in libraries cover a lot, many advanced tasks require specialized tools, this is where external libraries come in. These are packages developed by the Python community (or companies) and shared through the Python Package Index (PyPI). You usually install them using the package manager pip.\n\nWhat Are External Libraries?\n\nThey extend Python’s capabilities beyond the standard library.\nProvide tools for data science, machine learning, web development, image processing, automation, and much more.\nThey often come with many modules and sub-packages bundled together, making them powerful libraries.\n\n\n\nInstalling External Libraries\nNormally, you install external libraries using the command line:\npip install library-name\nFor example:\npip install numpy pip install pandas pip install matplotlib\nMost popular external libraries used for data science and scientific computing come pre-installed in JupyterLab environments such as: - Anaconda distribution (a popular Python distribution for data science) - Cloud platforms like Google Colab - Many managed JupyterHub setups\nThis means when you open a notebook in JupyterLab, you can often import and use libraries like numpy, pandas, and matplotlib immediately, no extra installation required.\nLet’s see some examples of these libraries:\n\n\nnumpy — Fast numerical computing\nProvides powerful arrays and mathematical functions.\n\n#Your code goes here\n\n\n\npandas — Data manipulation and analysis\nMakes working with tabular data easy.\n\n#Your code goes here\n\n\n\nmatplotlib — Data visualization\nCreate charts and graphs.\n\n#Your code goes here"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Coding Fundamentals for Humanists",
    "section": "",
    "text": "Software installation instructions\n\n\n\n\n\n\nMondayJune 2, 2025\n\n\n\n\nProgramming fundamentals\nIntroduction to the core concepts of programming languages\n\n\n\n\n\n\nTuesdayJune 3, 2025\n\n\n\n\nBasics of Python\nPython as an example of programming language\n\n\n\n\n\n\nWednesdayJune 4, 2025\n\n\n\n\nPython for the humanities\nExamples of use cases\n\n\n\n\n\n\nThursdayJune 5, 2025\n\n\n\n\nYour turn!\nQuery an API or scrape a website in teams\n\n\n\n\n\n\nFridayJune 6, 2025\n\n\n\n\nPresentations\nStress-free presentations of your results and what you learnt"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Coding Fundamentals for Humanists",
    "section": "",
    "text": "This workshop is part of the Digital Humanities Summer Institute (DHSI) 2025 event."
  },
  {
    "objectID": "about.html#instructors",
    "href": "about.html#instructors",
    "title": "About Coding Fundamentals for Humanists",
    "section": "Instructors",
    "text": "Instructors\n\n\n\n\n\n\nEvolutionary and behavioural ecologist by training, Software/Data Carpentry instructor, and open source advocate, Marie-Hélène Burle develops and delivers training for researchers on high-performance computing tools (R, Python, Julia, Git, Bash scripting, machine learning, parallel scientific programming, and HPC) for Simon Fraser University and the Digital Research Alliance of Canada.\n\n\n\n\n\n\n\n\n\n\n\n\nTannia Chevez joined ACENET in 2023 and is based in St. John’s. She has held positions as a research assistant in various departments, with responsibilities ranging from developing algorithms for an online animal sound repository, to crafting chemical composite films. She is proficient in Python, Java, and JavaScript. Her teaching experience includes a Leader Instructor at Brilliant Labs where she taught a range of digital topics, and a Digital Literacy Instructor for the Association for New Canadians."
  },
  {
    "objectID": "friday/index.html",
    "href": "friday/index.html",
    "title": "Presentations",
    "section": "",
    "text": "Time:\n9am–noon\nLive notes:\nEtherpad"
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Software installation instructions",
    "section": "",
    "text": "Python is a popular high-level programming language with applications in different fields of science and technology. Python is a powerful tool in data science as it can automate tasks and facilitate data analysis. One of the main reasons Python is a popular programming language is its extensive external libraries and packages which can introduce new functionalities, tailored to different applications, to the base version of Python. Installing all the external packages individually can be time-consuming and as such, we recommend Anaconda, an all-in-one installer which comes with the most popular external packages for Python.\nWe will teach Python using JupyterLab, a programming environment that runs in a web browser (JupyterLab will be installed by Anaconda automatically). For this to work you will need a reasonably up-to-date browser. The current versions of the Chrome, Safari, and Firefox browsers are all supported."
  },
  {
    "objectID": "install.html#python-setup-using-anaconda",
    "href": "install.html#python-setup-using-anaconda",
    "title": "Software installation instructions",
    "section": "",
    "text": "Python is a popular high-level programming language with applications in different fields of science and technology. Python is a powerful tool in data science as it can automate tasks and facilitate data analysis. One of the main reasons Python is a popular programming language is its extensive external libraries and packages which can introduce new functionalities, tailored to different applications, to the base version of Python. Installing all the external packages individually can be time-consuming and as such, we recommend Anaconda, an all-in-one installer which comes with the most popular external packages for Python.\nWe will teach Python using JupyterLab, a programming environment that runs in a web browser (JupyterLab will be installed by Anaconda automatically). For this to work you will need a reasonably up-to-date browser. The current versions of the Chrome, Safari, and Firefox browsers are all supported."
  },
  {
    "objectID": "install.html#installation",
    "href": "install.html#installation",
    "title": "Software installation instructions",
    "section": "Installation",
    "text": "Installation\n\nWindows users\n\nOpen this link.\nClick on the “Download” button. If you are not sure which version to choose, you probably want the 64-bit Graphical Installer Anaconda3-...-Windows-x86_64.exe.\n\n\n\n\n\n\n\nInstall Python 3 by running the Anaconda Installer:\n\n\n\n\nStep 1. Click on the “Next” button\n\n\n\n\n\nStep 2. Click on the “I Agree” button\n\n\n\n\n\nStep 3. Click on the “Next” button\n\n\n\n\n\nStep 4. Click on the “Next” button\n\n\n\n\n\nStep 5. Check “add Anaconda3 to my PATH environment variable” box and then click on “Install”\n\n\n\n\nmacOS users\n\nOpen this link.\nClick on the “Download” button which will then download the Anaconda Installer with Python 3 for macOS (you can either use the Graphical or the Command Line Installer).\nInstall Python 3 by running the Anaconda Installer using all the defaults.\n\n\n\nLinux users\n\nOpen this link.\nClick on the “Download” button and download the Anaconda Installer with Python 3 for Linux.\nOpen a terminal emulator and navigate to the directory where the executable is downloaded (e.g. cd ~/Downloads).\nType bash Anaconda3- then press Tab to autocomplete the full file name. The name of the file you just downloaded should appear.\nPress “Enter”. You will follow the text-only prompts. To move through the text, press the space bar. Type “yes” and press “Enter” to approve the license. Press “Enter” to approve the default location for the files. Type “yes” and press “Enter” to prepend Anaconda to your PATH (this makes the Anaconda distribution the default Python).\nClose the terminal window."
  },
  {
    "objectID": "install.html#testing-installation",
    "href": "install.html#testing-installation",
    "title": "Software installation instructions",
    "section": "Testing installation",
    "text": "Testing installation\nMake sure you can open JupyterLab in your browser: navigate to your terminal (“Anaconda Prompt” in Windows).\n\n\n\nIn Windows, look for “Anaconda Prompt”\n\n\nOnce you are in “Anaconda Prompt” (Windows), “Terminal” (macOS), or your usual terminal emulator (Linux), type jupyter lab and press “Enter”.\nIf you see a window similar to this screenshot in your browser, it means that you are good to go:"
  },
  {
    "objectID": "monday/index.html",
    "href": "monday/index.html",
    "title": "Programming fundamentals",
    "section": "",
    "text": "Time:\n11:00am–noon\nInstructor:\nMarie-Hélène Burle (Simon Fraser University)\nLive notes:\nFeel free to use the etherpad for this course to share notes or communicate among each other. It is entirely for you, so you can use it however you want.\nMaterial:\nSlides (this presentation may take a little time to load).\nTopic:\nAn introduction to the core concepts of programming languages."
  },
  {
    "objectID": "monday/index.html#programming-languages",
    "href": "monday/index.html#programming-languages",
    "title": "Programming fundamentals",
    "section": "",
    "text": "Time:\n11:00am–noon\nInstructor:\nMarie-Hélène Burle (Simon Fraser University)\nLive notes:\nFeel free to use the etherpad for this course to share notes or communicate among each other. It is entirely for you, so you can use it however you want.\nMaterial:\nSlides (this presentation may take a little time to load).\nTopic:\nAn introduction to the core concepts of programming languages."
  },
  {
    "objectID": "monday/index.html#jupyterlab-python",
    "href": "monday/index.html#jupyterlab-python",
    "title": "Programming fundamentals",
    "section": "JupyterLab & Python",
    "text": "JupyterLab & Python\n\nTime:\n1:30pm–4:00pm\nInstructor:\nTannia Chevez (ACENET)\nLive notes:\nEtherpad\nMaterial:\nDownload the Jupyter notebook for this afternoon:  Download \nYou will open this notebook on your computer and work in it.\nYou can see (but not edit) the content of the notebook here.\nAfter the end of today’s class, we will publish a completed notebook at the link above so that you don’t have to worry about missing something during the class: just focus on learning.\nPost course material:\nHere is the completed notebook:  Download \nAnd it can be visualized here."
  },
  {
    "objectID": "thursday/index.html",
    "href": "thursday/index.html",
    "title": "Your turn!",
    "section": "",
    "text": "Time:\n9am–noon, 1:30pm–4pm\nLive notes:\nEtherpad\nTopic:\nToday, you will be working in teams on a project of your own. Your goal is to extract useful data from a website, either via API querying (if the option is available) or via web scraping (if your site has no API).\nTry to pair up with one or more people having a similar interest.\nOf course, we will be with you all day to help!\nIt would be fantastic if you could chose a website that contains data useful for your research or that is of interest to you. If you don’t have any idea however, here is a list of sites that have well-built APIs:\n\nHathi Trust Hathifiles\nHathi Trust bibliographic API\nNew York Times\nInternet Archive\nSpotify\nGetty Museum\nLibrary of Congress\nWorld Bank\nNASA\n\nYou can find other sites with good APIs here and here."
  },
  {
    "objectID": "tuesday/index.html",
    "href": "tuesday/index.html",
    "title": "Basics of Python",
    "section": "",
    "text": "Time:\n9am–noon\nInstructor:\nTannia Chevez (ACENET)\nLive notes:\nEtherpad\nMaterial:\nDownload the Jupyter notebook for this morning:  Download \nYou will open this notebook on your computer and work in it.\nYou can see (but not edit) the content of the notebook here.\nAfter the end of today’s class, we will publish a completed notebook at the link above so that you don’t have to worry about missing something during the class: just focus on learning.\nPost course material:\nHere is the completed notebook:  Download \nAnd it can be visualized here."
  },
  {
    "objectID": "tuesday/index.html#dive-into-python",
    "href": "tuesday/index.html#dive-into-python",
    "title": "Basics of Python",
    "section": "",
    "text": "Time:\n9am–noon\nInstructor:\nTannia Chevez (ACENET)\nLive notes:\nEtherpad\nMaterial:\nDownload the Jupyter notebook for this morning:  Download \nYou will open this notebook on your computer and work in it.\nYou can see (but not edit) the content of the notebook here.\nAfter the end of today’s class, we will publish a completed notebook at the link above so that you don’t have to worry about missing something during the class: just focus on learning.\nPost course material:\nHere is the completed notebook:  Download \nAnd it can be visualized here."
  },
  {
    "objectID": "tuesday/index.html#using-ai-to-write-python-code",
    "href": "tuesday/index.html#using-ai-to-write-python-code",
    "title": "Basics of Python",
    "section": "Using AI to write Python code",
    "text": "Using AI to write Python code\n\nTime:\n1:30pm–4:00pm\nInstructor:\nMarie-Hélène Burle (Simon Fraser University)\nLive notes:\nEtherpad\nMaterial:\nWebsite\nTopic:\nLLMs have become extremely useful as a programming aid.\nThey can:\n\nauto-complete code,\nexplain programming concepts,\nexplain code,\nwrite code,\ndebug code,\nwrite software tests,\nwrite entire programs, websites, and applications (vibe coding).\n\nLet’s have a first try at it: we will use an LLM to download a text from the internet and do some basic text analyses. In the process, we will learn new Python concepts."
  },
  {
    "objectID": "wednesday/day3_morning.html",
    "href": "wednesday/day3_morning.html",
    "title": "Introduction to API Querying",
    "section": "",
    "text": "In today’s digital world, being able to access and work with online data is a valuable skill, even in the Humanities and Social Sciences. This session is all about getting comfortable with APIs (Application Programming Interfaces) and understanding why they’re useful for research. You’ll learn how APIs compare to other ways of getting data, like text mining and web scraping, and how to tell if a website has an API you can use. We’ll walk through how to make a request to an API, use parameters to get the exact data you want, and understand the responses you get back (usually in JSON format). By the end, you’ll have hands-on experience using APIs to gather and explore data for your own projects.\nLet’s get started by importing the libraries that we will be using:\n#Your code goes here\nLet’s explore the requests and json libraries using the Help function:\n#Your code goes here\n#Your code goes here\nLet’s get started with some hands-on API querying!\nFor our first example, we’ll use an easy-to-understand API from catfact.ninja, a site that serves up random cat facts, perfect for learning the basics in a fun way.\n1. Create a variable for base URL\nLet’s do a simple request and see what we get:\n#Your code goes here\n2. Create a variable for the cat facts response\n#Your code goes here\nLet’s explore the ‘responses’ library:\n#Your code goes here\n#Your code goes here\n#Your code goes here\nThe output for the .text function is actually JSON (Javascript object notation). If we apply a JSON method we can export this as a dictionary, which will be much easier for us to work with:\n#Your code goes here\n3. Querying parameters\n#Your code goes here\nLet’s create a variable to save this parameter:\n#Your code goes here"
  },
  {
    "objectID": "wednesday/day3_morning.html#exercise-1",
    "href": "wednesday/day3_morning.html#exercise-1",
    "title": "Introduction to API Querying",
    "section": "Exercise 1:",
    "text": "Exercise 1:\nQuery the /breeds attribute and limit our results to 10.\n\n#Your code goes here\n\n\n#Your code goes here\n\nLet’s try another example of API querying—this time with a sci-fi twist!\nWe’ll be using swapi.info, an API built specifically for exploring data from the Star Wars universe. It’s a great way to practice working with structured data while having a bit of fun with characters, planets, and starships.\nLet’s create a variable for the people attributes URL and do a simple request to it:\n\n#Your code goes here\n\nLet’s query the People attribute ID 1 by creating a variable\n\n#Your code goes here\n\nLet’s declare a second variable, called api_url_response:\n\n#Your code goes here\n\nJSON Format\nJSON data is formatted in key-value pairs. If you refer to the JSON data, you’ll see that it’s actually a list of keys and their corresponding values. For example, there’s a “birth_year” key whose value is “19BBY” as well as an “eye_color” key whose value is “blue.”\nWe can refer to the JSON data by its key:\n\n#Your code goes here\n\nIn the statement above, we are setting a new variable called hair. The variable is composed of the value of the hair_color key, as specified in the data you see in the previous cell.\nWe also set a variable called name, which is composed of the value of the name key. Then we tell the program to print those values"
  },
  {
    "objectID": "wednesday/day3_morning.html#exercise-2",
    "href": "wednesday/day3_morning.html#exercise-2",
    "title": "Introduction to API Querying",
    "section": "Exercise 2",
    "text": "Exercise 2\nWrite some code that uses the API to tell us Luke Skywalker’s eye color.\n\n#Your code goes here"
  },
  {
    "objectID": "wednesday/day3_morning.html#exercise-3",
    "href": "wednesday/day3_morning.html#exercise-3",
    "title": "Introduction to API Querying",
    "section": "Exercise 3",
    "text": "Exercise 3\nLet’s try a different attribute! Choose one from the documentation: swapi.info\nTry choosing a specific endpoint associated with an attribute to create a full string."
  },
  {
    "objectID": "monday/day1_afternoon_completed.html",
    "href": "monday/day1_afternoon_completed.html",
    "title": "Introduction to Python for Digital Humanities",
    "section": "",
    "text": "The Digital Humanities (DH) is an interdisciplinary field that brings together computational tools and methods with traditional disciplines in the humanities, such as history, literature, art history, linguistics, philosophy, and cultural studies. As the volume of digital cultural content grows—such as digitized manuscripts, historical records, social media posts, and multimedia archives—the need to process, analyze, and interpret these materials using digital tools becomes increasingly important."
  },
  {
    "objectID": "monday/day1_afternoon_completed.html#introduction-to-jupyterlab",
    "href": "monday/day1_afternoon_completed.html#introduction-to-jupyterlab",
    "title": "Introduction to Python for Digital Humanities",
    "section": "Introduction to JupyterLab",
    "text": "Introduction to JupyterLab\nJupyterLab is an interactive computing environment that allows you to create and share documents containing live code, equations, visualizations, and narrative text. It is commonly used in data science, research, and education, especially for projects in the Digital Humanities, because of its flexibility and ease of use. JupyterLab is essentially an upgrade of Jupyter Notebooks, providing a more modular and feature-rich interface.\n\nKey Features of JupyterLab:\n\nCode cells: These are cells where you write and execute code.\nMarkdown cells: These cells are used for explanatory text, formatted using Markdown.\nRich outputs: Visualizations, graphs, images, and other media can be displayed inline within the notebook.\nFile management: JupyterLab has a built-in file browser that allows you to organize and manage notebooks, text files, images, and other resources.\n\n\n\nHow to Add Cells in JupyterLab\nIn JupyterLab, cells are the building blocks of your notebook. You can add, delete, and modify cells to create a flow between code execution and explanatory text.\n\nAdding Cells:\n\nVia Menu: Navigate to the top menu: Insert → Insert Cell Below or Insert → Insert Cell Above.\nKeyboard Shortcuts: Press B to insert a cell below the current one or A to insert a cell above.\nClicking Buttons: Use the “+” button in the toolbar to insert new cells.\n\n\n\nSwitching Between Cell Types (Code and Markdown):\nYou can switch between code cells and markdown cells to organize your content effectively.\n\nTo Change a Cell Type to Code:\n\n\nSelect the cell and press Y.\nAlternatively, click on the Cell Type dropdown menu in the toolbar (where “Markdown” is by default) and select Code.\n\n\nTo Change a Cell Type to Markdown:\n\n\nSelect the cell and press M.\nAlternatively, use the Cell Type dropdown and select Markdown.\n\nThis allows you to seamlessly switch between running code and writing descriptive text.\n\n\nRunning and Stopping Cells\nCells in JupyterLab can either be run (executed) or stopped, depending on whether you want to see the result of the code.\n\nRunning Cells: To execute a cell, you can:\n\n\nWindows/Linux: Press Shift + Enter to run the current cell and move to the next.\nMac: Press Shift + Enter to run the current cell and move to the next. You can also use command + Enter to run the cell and stay in that cell.\nAlternatively, click the Run button in the toolbar.\n\n\nStopping a Cell: If you want to stop the execution of a cell:\n\n\nNavigate to Kernel → Interrupt in the top menu or use the Stop button in the toolbar.\nAlternatively, use the keyboard shortcut I twice (press I quickly two times) to interrupt the current execution.\n\n\n\n\nThe Kernel in JupyterLab\nThe kernel is the engine behind your notebook, it runs your Python code and remembers what you’ve done.\nWhen you press Shift + Enter to run a cell, the kernel executes that code and gives you a result (a number, a list, a graph, etc.).\n\nUnderstanding [ ], [*], and [1] in Jupyter Cells\nEvery time you run a code cell, you’ll see a number appear inside square brackets next to the cell, like this:\n\nprint(\"Hello\")\n\nHello\n\n\nHere’s what those brackets mean:\n[ ] — The cell has not been run yet.\n[*] — The code is currently running (kernel is busy).\n[1], [2], … — The number shows the order in which you ran the cells.\nFor example:\nIf you see [5] next to a cell, it means this was the fifth cell you ran.\nIf a cell is stuck on [*], it might be taking a long time or be stuck — you can stop it using Kernel → Interrupt.\n\n\nCommon Kernel Actions:\n\nRun code: Shift + Enter\nInterrupt kernel: Stop a running cell (especially useful if stuck on [*])\nRestart kernel: Clears everything the kernel remembers (variables, imports, etc.)\n\nUse Kernel → Restart if things get messy or confusing — then rerun your cells from the top to start fresh."
  },
  {
    "objectID": "monday/day1_afternoon_completed.html#built-in-functions-and-documentation",
    "href": "monday/day1_afternoon_completed.html#built-in-functions-and-documentation",
    "title": "Introduction to Python for Digital Humanities",
    "section": "Built-in Functions and Documentation",
    "text": "Built-in Functions and Documentation\nPython provides a wide range of built-in functions—these are standard, preloaded tools that help with common tasks. They require no additional libraries or installations and are available immediately when you run Python.\n\nWhat Are Built-in Functions?\nA built-in function is a function that is always available in Python. These are designed to simplify common programming tasks. For instance, rather than writing your own code to calculate the length of a string, you can use len().\nBuilt-in functions improve productivity and reduce the need for writing code from scratch for basic operations.\n\n\nCommon Built-in Functions and What They Do:\n\nprint(): Displays text or variable output.\nlen(): Returns the number of items in an object (string, list, etc.).\ntype(): Returns the data type of a variable (e.g., int, str).\nint(), float(), str(): Convert between data types.\nrange(): Produces a sequence of numbers, often used in loops.\nsum(): Adds numbers in a list or iterable.\nsorted(): Returns a new list containing all items from the iterable in ascending order.\nmax() / min(): Finds the largest or smallest value in a dataset.\n\n\n# Example 1: Basic text output\nprint(\"Welcome to Digital Humanities\")\n\n# Example 2: Working with a string\nsentence = \"Humanities meet computation\"\nprint(\"Length of sentence:\", len(sentence))\n\n# Example 3: Check data type\nnumber = 42\nprint(\"Data type:\", type(number))\n\n# Example 4: Sorting a list\nyears = [1850, 2023, 1945, 1789]\nprint(\"Sorted years:\", sorted(years))\n\n# Example 5: Using range and sum\nprint(\"Sum from 1 to 5:\", sum(range(1, 6)))  # 1+2+3+4+5 = 15\n\nWelcome to Digital Humanities\nLength of sentence: 27\nData type: &lt;class 'int'&gt;\nSorted years: [1789, 1850, 1945, 2023]\nSum from 1 to 5: 15\n\n\n\n\nExploring Python Documentation\nLearning how to explore the documentation is key to becoming self-sufficient in Python.\nPython provides tools for this: - help() function - The ? syntax in Jupyter Notebooks\n\nhelp(str)\n\nHelp on class str in module builtins:\n\nclass str(object)\n |  str(object='') -&gt; str\n |  str(bytes_or_buffer[, encoding[, errors]]) -&gt; str\n |\n |  Create a new string object from the given object. If encoding or\n |  errors is specified, then the object must expose a data buffer\n |  that will be decoded using the given encoding and error handler.\n |  Otherwise, returns the result of object.__str__() (if defined)\n |  or repr(object).\n |  encoding defaults to 'utf-8'.\n |  errors defaults to 'strict'.\n |\n |  Methods defined here:\n |\n |  __add__(self, value, /)\n |      Return self+value.\n |\n |  __contains__(self, key, /)\n |      Return bool(key in self).\n |\n |  __eq__(self, value, /)\n |      Return self==value.\n |\n |  __format__(self, format_spec, /)\n |      Return a formatted version of the string as described by format_spec.\n |\n |  __ge__(self, value, /)\n |      Return self&gt;=value.\n |\n |  __getitem__(self, key, /)\n |      Return self[key].\n |\n |  __getnewargs__(self, /)\n |\n |  __gt__(self, value, /)\n |      Return self&gt;value.\n |\n |  __hash__(self, /)\n |      Return hash(self).\n |\n |  __iter__(self, /)\n |      Implement iter(self).\n |\n |  __le__(self, value, /)\n |      Return self&lt;=value.\n |\n |  __len__(self, /)\n |      Return len(self).\n |\n |  __lt__(self, value, /)\n |      Return self&lt;value.\n |\n |  __mod__(self, value, /)\n |      Return self%value.\n |\n |  __mul__(self, value, /)\n |      Return self*value.\n |\n |  __ne__(self, value, /)\n |      Return self!=value.\n |\n |  __repr__(self, /)\n |      Return repr(self).\n |\n |  __rmod__(self, value, /)\n |      Return value%self.\n |\n |  __rmul__(self, value, /)\n |      Return value*self.\n |\n |  __sizeof__(self, /)\n |      Return the size of the string in memory, in bytes.\n |\n |  __str__(self, /)\n |      Return str(self).\n |\n |  capitalize(self, /)\n |      Return a capitalized version of the string.\n |\n |      More specifically, make the first character have upper case and the rest lower\n |      case.\n |\n |  casefold(self, /)\n |      Return a version of the string suitable for caseless comparisons.\n |\n |  center(self, width, fillchar=' ', /)\n |      Return a centered string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  count(self, sub[, start[, end]], /)\n |      Return the number of non-overlapping occurrences of substring sub in string S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |\n |  encode(self, /, encoding='utf-8', errors='strict')\n |      Encode the string using the codec registered for encoding.\n |\n |      encoding\n |        The encoding in which to encode the string.\n |      errors\n |        The error handling scheme to use for encoding errors.\n |        The default is 'strict' meaning that encoding errors raise a\n |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n |        'xmlcharrefreplace' as well as any other name registered with\n |        codecs.register_error that can handle UnicodeEncodeErrors.\n |\n |  endswith(self, suffix[, start[, end]], /)\n |      Return True if the string ends with the specified suffix, False otherwise.\n |\n |      suffix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  expandtabs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |\n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |\n |  find(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  format(self, /, *args, **kwargs)\n |      Return a formatted version of the string, using substitutions from args and kwargs.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  format_map(self, mapping, /)\n |      Return a formatted version of the string, using substitutions from mapping.\n |      The substitutions are identified by braces ('{' and '}').\n |\n |  index(self, sub[, start[, end]], /)\n |      Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  isalnum(self, /)\n |      Return True if the string is an alpha-numeric string, False otherwise.\n |\n |      A string is alpha-numeric if all characters in the string are alpha-numeric and\n |      there is at least one character in the string.\n |\n |  isalpha(self, /)\n |      Return True if the string is an alphabetic string, False otherwise.\n |\n |      A string is alphabetic if all characters in the string are alphabetic and there\n |      is at least one character in the string.\n |\n |  isascii(self, /)\n |      Return True if all characters in the string are ASCII, False otherwise.\n |\n |      ASCII characters have code points in the range U+0000-U+007F.\n |      Empty string is ASCII too.\n |\n |  isdecimal(self, /)\n |      Return True if the string is a decimal string, False otherwise.\n |\n |      A string is a decimal string if all characters in the string are decimal and\n |      there is at least one character in the string.\n |\n |  isdigit(self, /)\n |      Return True if the string is a digit string, False otherwise.\n |\n |      A string is a digit string if all characters in the string are digits and there\n |      is at least one character in the string.\n |\n |  isidentifier(self, /)\n |      Return True if the string is a valid Python identifier, False otherwise.\n |\n |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,\n |      such as \"def\" or \"class\".\n |\n |  islower(self, /)\n |      Return True if the string is a lowercase string, False otherwise.\n |\n |      A string is lowercase if all cased characters in the string are lowercase and\n |      there is at least one cased character in the string.\n |\n |  isnumeric(self, /)\n |      Return True if the string is a numeric string, False otherwise.\n |\n |      A string is numeric if all characters in the string are numeric and there is at\n |      least one character in the string.\n |\n |  isprintable(self, /)\n |      Return True if all characters in the string are printable, False otherwise.\n |\n |      A character is printable if repr() may use it in its output.\n |\n |  isspace(self, /)\n |      Return True if the string is a whitespace string, False otherwise.\n |\n |      A string is whitespace if all characters in the string are whitespace and there\n |      is at least one character in the string.\n |\n |  istitle(self, /)\n |      Return True if the string is a title-cased string, False otherwise.\n |\n |      In a title-cased string, upper- and title-case characters may only\n |      follow uncased characters and lowercase characters only cased ones.\n |\n |  isupper(self, /)\n |      Return True if the string is an uppercase string, False otherwise.\n |\n |      A string is uppercase if all cased characters in the string are uppercase and\n |      there is at least one cased character in the string.\n |\n |  join(self, iterable, /)\n |      Concatenate any number of strings.\n |\n |      The string whose method is called is inserted in between each given string.\n |      The result is returned as a new string.\n |\n |      Example: '.'.join(['ab', 'pq', 'rs']) -&gt; 'ab.pq.rs'\n |\n |  ljust(self, width, fillchar=' ', /)\n |      Return a left-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  lower(self, /)\n |      Return a copy of the string converted to lowercase.\n |\n |  lstrip(self, chars=None, /)\n |      Return a copy of the string with leading whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  partition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string.  If the separator is found,\n |      returns a 3-tuple containing the part before the separator, the separator\n |      itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing the original string\n |      and two empty strings.\n |\n |  removeprefix(self, prefix, /)\n |      Return a str with the given prefix string removed if present.\n |\n |      If the string starts with the prefix string, return string[len(prefix):].\n |      Otherwise, return a copy of the original string.\n |\n |  removesuffix(self, suffix, /)\n |      Return a str with the given suffix string removed if present.\n |\n |      If the string ends with the suffix string and that suffix is not empty,\n |      return string[:-len(suffix)]. Otherwise, return a copy of the original\n |      string.\n |\n |  replace(self, old, new, /, count=-1)\n |      Return a copy with all occurrences of substring old replaced by new.\n |\n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |\n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |\n |  rfind(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Return -1 on failure.\n |\n |  rindex(self, sub[, start[, end]], /)\n |      Return the highest index in S where substring sub is found, such that sub is contained within S[start:end].\n |\n |      Optional arguments start and end are interpreted as in slice notation.\n |      Raises ValueError when the substring is not found.\n |\n |  rjust(self, width, fillchar=' ', /)\n |      Return a right-justified string of length width.\n |\n |      Padding is done using the specified fill character (default is a space).\n |\n |  rpartition(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |\n |      This will search for the separator in the string, starting at the end. If\n |      the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it.\n |\n |      If the separator is not found, returns a 3-tuple containing two empty strings\n |      and the original string.\n |\n |  rsplit(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the end of the string and works to the front.\n |\n |  rstrip(self, chars=None, /)\n |      Return a copy of the string with trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  split(self, /, sep=None, maxsplit=-1)\n |      Return a list of the substrings in the string, using sep as the separator string.\n |\n |        sep\n |          The separator used to split the string.\n |\n |          When set to None (the default value), will split on any whitespace\n |          character (including \\n \\r \\t \\f and spaces) and will discard\n |          empty strings from the result.\n |        maxsplit\n |          Maximum number of splits.\n |          -1 (the default value) means no limit.\n |\n |      Splitting starts at the front of the string and works to the end.\n |\n |      Note, str.split() is mainly useful for data that has been intentionally\n |      delimited.  With natural text that includes punctuation, consider using\n |      the regular expression module.\n |\n |  splitlines(self, /, keepends=False)\n |      Return a list of the lines in the string, breaking at line boundaries.\n |\n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |\n |  startswith(self, prefix[, start[, end]], /)\n |      Return True if the string starts with the specified prefix, False otherwise.\n |\n |      prefix\n |        A string or a tuple of strings to try.\n |      start\n |        Optional start position. Default: start of the string.\n |      end\n |        Optional stop position. Default: end of the string.\n |\n |  strip(self, chars=None, /)\n |      Return a copy of the string with leading and trailing whitespace removed.\n |\n |      If chars is given and not None, remove characters in chars instead.\n |\n |  swapcase(self, /)\n |      Convert uppercase characters to lowercase and lowercase characters to uppercase.\n |\n |  title(self, /)\n |      Return a version of the string where each word is titlecased.\n |\n |      More specifically, words start with uppercased characters and all remaining\n |      cased characters have lower case.\n |\n |  translate(self, table, /)\n |      Replace each character in the string using the given translation table.\n |\n |        table\n |          Translation table, which must be a mapping of Unicode ordinals to\n |          Unicode ordinals, strings, or None.\n |\n |      The table must implement lookup/indexing via __getitem__, for instance a\n |      dictionary or list.  If this operation raises LookupError, the character is\n |      left untouched.  Characters mapped to None are deleted.\n |\n |  upper(self, /)\n |      Return a copy of the string converted to uppercase.\n |\n |  zfill(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |\n |      The string is never truncated.\n |\n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |\n |  __new__(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |\n |  maketrans(x, y=&lt;unrepresentable&gt;, z=&lt;unrepresentable&gt;, /)\n |      Return a translation table usable for str.translate().\n |\n |      If there is only one argument, it must be a dictionary mapping Unicode\n |      ordinals (integers) or characters to Unicode ordinals, strings or None.\n |      Character keys will be then converted to ordinals.\n |      If there are two arguments, they must be strings of equal length, and\n |      in the resulting dictionary, each character in x will be mapped to the\n |      character at the same position in y. If there is a third argument, it\n |      must be a string, whose characters will be mapped to None in the result.\n\n\n\nThis gives detailed information about how to work with strings.\n\nstr?\n\nThis brings up a quick help popup describing the str class.\nYou can also combine help with other functions:\n\nhelp(len)\n\nHelp on built-in function len in module builtins:\n\nlen(obj, /)\n    Return the number of items in a container.\n\n\n\nThis shows how the len() function works and what types it supports."
  },
  {
    "objectID": "monday/day1_afternoon_completed.html#libraries-and-modules",
    "href": "monday/day1_afternoon_completed.html#libraries-and-modules",
    "title": "Introduction to Python for Digital Humanities",
    "section": "Libraries and Modules",
    "text": "Libraries and Modules\nPython’s strength lies in its standard library and external packages—collections of modules that offer specialized functionality. A module is simply a file containing Python definitions and statements. A library is a collection of modules that can be imported and used in your programs.\n\nWhy Libraries Matter:\nThey save time and provide tested, optimized tools for: - Text processing - Data handling - Visualization - Machine learning - File and network operations\n\n\nImporting Modules\nTo use a module, you import it into your Python script:\n\nimport math\nprint(math.sqrt(16))  # Output: 4.0\n\n4.0\n\n\nYou can also import specific functions or classes:\n\nfrom math import pi, sin\nprint(pi)         # Output: 3.141592653589793\nprint(sin(pi/2))  # Output: 1.0\n\n3.141592653589793\n1.0\n\n\nOr give a library module an alias:\n\nimport numpy as np\narray = np.array([1, 2, 3])\narray\n\narray([1, 2, 3])\n\n\n\n\nBuilt-in Python Libraries\nPython comes with a rich standard library — a collection of modules and packages that are bundled with Python itself. This means you don’t need to install anything extra to start using them. They’re always available whenever you run Python, making it super convenient to perform many common programming tasks right out of the box.\n\nrandom : Generate random numbers\nUseful for creating random data, games, simulations, or selecting random elements.\n\nimport random\nprint(random.randint(1, 10))  # Random number between 1 and 10\n\n10\n\n\n\n\ndatetime — Work with dates and times\nEasily get the current date/time or perform date calculations.\n\nimport datetime\nnow = datetime.datetime.now()\nprint(now.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n2025-06-03 09:30:37\n\n\n\n\nos — Interact with your computer’s operating system\nGet info about files, directories, environment variables, or execute system commands.\n\nimport os\n\nprint(os.getcwd())  # Current working directory\nprint(os.listdir()) # List files in the current directory\n\n/home/marie/parvus/prog/dhsi/2025_dhsi/monday\n['day1_afternoon_completed.quarto_ipynb', '.jupyter_cache', 'index.qmd', 'day1_afternoon.ipynb', 'day1_afternoon_completed.qmd', 'wb_hss_prog_slides.qmd', 'day1_afternoon_completed.ipynb', 'day1_afternoon.qmd']\n\n\n\n\n\nExternal Libraries\nWhile Python’s built-in libraries cover a lot, many advanced tasks require specialized tools, this is where external libraries come in. These are packages developed by the Python community (or companies) and shared through the Python Package Index (PyPI). You usually install them using the package manager pip.\n\nWhat Are External Libraries?\n\nThey extend Python’s capabilities beyond the standard library.\nProvide tools for data science, machine learning, web development, image processing, automation, and much more.\nThey often come with many modules and sub-packages bundled together, making them powerful libraries.\n\n\n\nInstalling External Libraries\nNormally, you install external libraries using the command line:\npip install library-name\nFor example:\npip install numpy pip install pandas pip install matplotlib\nMost popular external libraries used for data science and scientific computing come pre-installed in JupyterLab environments such as: - Anaconda distribution (a popular Python distribution for data science) - Cloud platforms like Google Colab - Many managed JupyterHub setups\nThis means when you open a notebook in JupyterLab, you can often import and use libraries like numpy, pandas, and matplotlib immediately, no extra installation required.\nLet’s see some examples of these libraries:\n\n\nnumpy — Fast numerical computing\nProvides powerful arrays and mathematical functions.\n\nimport numpy as np\n\narr = np.array([1, 2, 3])\nprint(arr * 2)  # [2 4 6]\n\n[2 4 6]\n\n\n\n\npandas — Data manipulation and analysis\nMakes working with tabular data easy.\n\nimport pandas as pd\n\ndata = {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\ndf = pd.DataFrame(data)\nprint(df)\n\n    Name  Age\n0  Alice   25\n1    Bob   30\n\n\n\n\nmatplotlib — Data visualization\nCreate charts and graphs.\n\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4]\ny = [10, 20, 25, 30]\n\nplt.plot(x, y)\nplt.title(\"Simple Line Plot\")\nplt.show()"
  },
  {
    "objectID": "tuesday/day2_morning_completed.html",
    "href": "tuesday/day2_morning_completed.html",
    "title": "Introductory Programming with Python",
    "section": "",
    "text": "Before we jump into analyzing data, let’s talk about one of the most powerful tools in programming: variables. Think of a variable like a storage box where you can put information that you might want to use later. This is how we make computers remember things for us!\nLet’s start with something simple. Imagine using Python like a calculator. You can do quick math, like this:\n\n2 + 5 * 8\n\n42\n\n\nThis is very handy, but let’s be honest, it’s not very exciting. What makes programming powerful is the ability to store this result or any other data, and use it again whenever we need it. That’s where variables come in.\n\n\nA variable is a name that refers to a value. In the previous example, we saw that we can use Python as an advanced calculator. However, the results of these computations are lost after we perform our operations. If we want to save and reuse any value in a code, we need to save these computations in a place in computer memory to be able to access it in the future.\nVariables are names that we associate with a memory location in computers. As such variables are not values themselves but they point to a memory location where the actual values are stored.\n\nweight_kg = 60\nweight_kg\n\n60\n\n\nNow, Python will remember that weight_kg equals 60. Instead of doing the math all over again or writing the number repeatedly, we just use weight_kg whenever we need it.\nA Few Rules for Naming Variables: - You can use letters, digits, and **underscores (_), but the name can’t** start with a digit. - Variable names are case-sensitive, so weight and Weight are two different things.\nFor example: - weight0 is valid, but 0weight isn’t. - weight_kg is different from Weight_kg.\n\n\n\nPython can work with different types of data. Three of the most common types are:\n\nIntegers (whole numbers like 1, 2, 100)\nFloating point numbers (numbers with decimals like 2.5, 60.3)\nStrings (text like “Hello”, “001”)\nBooleans (True or False)\n\nFor example, let’s say we want to store a patient’s weight. If the weight is exactly 60 kilograms, we can use an integer:\n\nweight_kg = 75\n\nBut if we want to be more precise, like 60.3 kilograms, we can use a floating point number:\n\nweight_kg = 75.3\n\nHere, weight_kg is a variable that stores a decimal number, or a float. It could represent any weight in kg measurement, which we might later use for calculations or comparisons.\nWe can also store text:\n\nname = \"John Doe\"\n\nStrings can store text data, which can be useful for labeling or adding metadata.\nAnd lastly, we have booleans, which are used to represent true or false values. They are helpful in logical operations or conditions:\n\nheight_cm = 165\n\nis_tall= height_cm &gt; 180 \n\nis_tall\n\nFalse\n\n\nWith this variable, we could decide whether to apply certain calculations or adjustments based on the height. It can help us write cleaner, more conditional code."
  },
  {
    "objectID": "tuesday/day2_morning_completed.html#variables",
    "href": "tuesday/day2_morning_completed.html#variables",
    "title": "Introductory Programming with Python",
    "section": "",
    "text": "Before we jump into analyzing data, let’s talk about one of the most powerful tools in programming: variables. Think of a variable like a storage box where you can put information that you might want to use later. This is how we make computers remember things for us!\nLet’s start with something simple. Imagine using Python like a calculator. You can do quick math, like this:\n\n2 + 5 * 8\n\n42\n\n\nThis is very handy, but let’s be honest, it’s not very exciting. What makes programming powerful is the ability to store this result or any other data, and use it again whenever we need it. That’s where variables come in.\n\n\nA variable is a name that refers to a value. In the previous example, we saw that we can use Python as an advanced calculator. However, the results of these computations are lost after we perform our operations. If we want to save and reuse any value in a code, we need to save these computations in a place in computer memory to be able to access it in the future.\nVariables are names that we associate with a memory location in computers. As such variables are not values themselves but they point to a memory location where the actual values are stored.\n\nweight_kg = 60\nweight_kg\n\n60\n\n\nNow, Python will remember that weight_kg equals 60. Instead of doing the math all over again or writing the number repeatedly, we just use weight_kg whenever we need it.\nA Few Rules for Naming Variables: - You can use letters, digits, and **underscores (_), but the name can’t** start with a digit. - Variable names are case-sensitive, so weight and Weight are two different things.\nFor example: - weight0 is valid, but 0weight isn’t. - weight_kg is different from Weight_kg.\n\n\n\nPython can work with different types of data. Three of the most common types are:\n\nIntegers (whole numbers like 1, 2, 100)\nFloating point numbers (numbers with decimals like 2.5, 60.3)\nStrings (text like “Hello”, “001”)\nBooleans (True or False)\n\nFor example, let’s say we want to store a patient’s weight. If the weight is exactly 60 kilograms, we can use an integer:\n\nweight_kg = 75\n\nBut if we want to be more precise, like 60.3 kilograms, we can use a floating point number:\n\nweight_kg = 75.3\n\nHere, weight_kg is a variable that stores a decimal number, or a float. It could represent any weight in kg measurement, which we might later use for calculations or comparisons.\nWe can also store text:\n\nname = \"John Doe\"\n\nStrings can store text data, which can be useful for labeling or adding metadata.\nAnd lastly, we have booleans, which are used to represent true or false values. They are helpful in logical operations or conditions:\n\nheight_cm = 165\n\nis_tall= height_cm &gt; 180 \n\nis_tall\n\nFalse\n\n\nWith this variable, we could decide whether to apply certain calculations or adjustments based on the height. It can help us write cleaner, more conditional code."
  },
  {
    "objectID": "tuesday/day2_morning_completed.html#basic-operations-with-variables",
    "href": "tuesday/day2_morning_completed.html#basic-operations-with-variables",
    "title": "Introductory Programming with Python",
    "section": "Basic Operations with Variables",
    "text": "Basic Operations with Variables\n\nWorking with Numbers: Integers and Floats\nAddition is one of the simplest operations. If you want to increase a value, you just add to it. For example, if you have a population measurement of 20000 and want to add 5000 more, Python gives you a new population number of 25000 like this:\n\npopulation = 20000  # current population of a town\n\nnew_population = population + 5000  # population increase after migration\n\nnew_population\n\n25000\n\n\nOther operations are just as simple. If you want to double a temperature value, you multiply it by 2 like this:\n\ntemperature = 4.5 \ndoubled_temp = temperature * 2\n\ndoubled_temp\n\n9.0\n\n\nDivision also works the same way: dividing 20000 by 100 gives 200.0 like this:\n\npopulation_ratio = population / 100\npopulation_ratio\n\n200.0\n\n\nPython can also handle exponents, like squaring numbers. If you want to find what 20000 times 20000 is, you can get it this way:\n\nsquared_population = population ** 2\nsquared_population\n\n400000000\n\n\nThis is useful for calculating things like squared distances or other exponential relationships.\n### Exercise 1: You are studying urban growth in a geography class. City A had a population of 1,500,000 people in the year 2000, and it grew to 2,100,000 people by the year 2020.\nYour task is to write a Python program that: - Stores the population values in variables. - Calculates how much the population has grown. - Displays the result using print().\n\npopulation_2000 = 1500000\npopulation_2020 = 2100000\ngrowth = population_2020 - population_2000\n\nprint(\"Population growth over 20 years:\", growth)\n\nPopulation growth over 20 years: 600000\n\n\n\npopulation_2000 = 1500000\npopulation_2020 = 2100000\n\ngrowth_percentage = ((population_2020 - population_2000) / population_2000) * 100\n\nprint(\"Population growth over 20 years: {:.2f}%\".format(growth_percentage))\n\nPopulation growth over 20 years: 40.00%\n\n\n\n\nWorking with Strings\nWith strings, one common thing we do is combine them, known as concatenation. Imagine you have two words, first name and last name, like “John” and “Doe”, and you want to make them into one full name: “John Doe.” You do this by placing them side by side with a plus sign between them, and Python combines them into one.\n\nfirst_name = 'John'\nlast_name = 'Doe'\nfull_name = first_name + \" \" + last_name\n\nfull_name\n\n'John Doe'\n\n\nAnother thing you can do with strings is repeat them. For instance, if you have the word “hello,” you could repeat it multiple times, like “hello hello hello” In Python, you simply tell it to multiply the word by the number of times you want it to appear like this:\n\necho = \" hello\" * 3\necho\n\n' hello hello hello'\n\n\n\n\nWorking with Booleans\nBooleans in Python are very straightforward: they represent only two options, True or False. They’re useful when you’re asking questions or checking if something meets certain conditions.\nFor example, let’s say you want to check if a town’s population is above a certain number. Imagine the town has a population of 20,000 people, and you want to know if it’s larger than 10,000:\n\npopulation = 20000  # current population of a town\n\nis_large_town = population &gt; 10000  # check if it's considered a large town\n\nis_large_town\n\nTrue\n\n\nWe can also ask Python to check multiple conditions at once. Maybe you want to know if a town has both a large population (over 10,000 people) and a low unemployment rate (under 5%). You can combine these two questions into one. If both are true, Python returns True; if either one isn’t, it returns False.\n\npopulation = 20000\nis_large = population &gt; 10000\n\nunemployment_rate = 4  # in percent\nis_low_unemployment = unemployment_rate &lt; 5\n\nis_large_and_stable = is_large and is_low_unemployment\nis_large_and_stable\n\nTrue\n\n\n\n\nMixing Types Together\nSometimes, Python lets us mix different types in ways that make sense. For example, in Python, True is treated as 1 and False as 0. So if you’re working with a number and a condition, Python might add 1 if the condition is True, or add nothing if it’s False. This can be handy for quick adjustments, like slightly increasing a value if a condition is met.\nadjusted_population = population + is_low_unemployment adjusted_population\nThese simple operations let you do quite a bit in Python. With strings, you can create descriptive phrases; with numbers, you can add, multiply, and do more complex math; with booleans, you can check conditions and make decisions. This flexibility is what makes Python both powerful and beginner-friendly—it’s easy to write code that mimics real-world problem-solving, step by step."
  },
  {
    "objectID": "tuesday/day2_morning_completed.html#data-structures",
    "href": "tuesday/day2_morning_completed.html#data-structures",
    "title": "Introductory Programming with Python",
    "section": "Data Structures",
    "text": "Data Structures\nData structures are essential for organizing and managing data in programming. In Python, we have several types of data structures, but three of the most commonly used ones are lists, tuples, and dictionaries. Each of these has unique characteristics and uses that make them suitable for different tasks.\n\nLists\nA list in Python is a collection of items that can be modified. This means you can add, remove, or change items in a list as needed. Lists are defined using square brackets []:\n\ngrades = [85.5, 90.2, 78.0, 88.5]  \ngrades  \n\n[85.5, 90.2, 78.0, 88.5]\n\n\nIn this example, we have a list called grades that stores test scores from different students.\n\nUsing Lists:\n1. Accessing Lists: Each item in a list has a position called an index, starting from 0. You can access any item using its index:\n\nfirst_grade = grades[0]\nfirst_grade\n\n85.5\n\n\n2. Modifying Items: Lists are mutable, meaning you can change their contents:\n\ngrades[2] = 93.0\ngrades[2] \n\n93.0\n\n\n3. Adding Items: You can add new items to the end of a list using the append() method:\n\ngrades.append(65.0)\ngrades\n\n[85.5, 90.2, 93.0, 88.5, 65.0]\n\n\n4. Removing Items: You can remove items from a list using the remove() method or the pop() method:\n\ngrades.remove(65.0)\ngrades\n\n[85.5, 90.2, 93.0, 88.5]\n\n\n\ngrades.pop(0)\ngrades\n\n[90.2, 93.0, 88.5]\n\n\nConsider a scenario where you are recording student test scores for a class. You can store these scores in a list. As new test results come in, you can easily update the list by adding new scores or modifying existing ones.\n\n\n\nExercise 2\n\nCreate a list named philosophers that contains these names as strings: “Plato”, “Aristotle”, “Confucius”, and “Socrates”.\nAdd the philosopher “Descartes” to the end of the list.\nRemove “Confucius” from the list.\nPrint the updated list to see the changes.\n\n\nphilosophers = [\"Plato\", \"Aristotle\", \"Confucius\", \"Socrates\"]\n\n# Add \"Descartes\" to the list\nphilosophers.append(\"Descartes\")\n\n# Remove \"Confucius\" from the list\n# Option 1:\n# philosophers.remove(\"Confucius\")\n\n# Option 2 (remove by index):\n# philosophers.pop(2)\n\nprint(philosophers)\n\n['Plato', 'Aristotle', 'Confucius', 'Socrates', 'Descartes']\n\n\n\n\nTuples\nA tuple is a collection of items, similar to a list, but it is immutable. This means that once a tuple is created, it cannot be changed. Tuples are defined using parentheses ().\n\ncoordinates = (47.5, -52.3) \ncoordinates\n\n(47.5, -52.3)\n\n\nThis tuple represents the geographic coordinates of a specific location.\n\nUsing Tuples:\n1. Accessing Items: Just like lists, you can access items in a tuple using their index:\n\nlatitude = coordinates[0]\nlatitude\n\n47.5\n\n\n\ncoordinates[0] = 48.5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[68], line 1\n----&gt; 1 coordinates[0] = 48.5\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n2. Benefits of Immutability: Since tuples cannot be changed, they are useful for storing fixed data that should not be altered. This can help prevent accidental changes to important values.\nIn oceanography, you might want to store the coordinates of a specific research station. Since these coordinates are fixed and won’t change, a tuple is the ideal choice. If you need to reference these coordinates later in your code, you can do so confidently, knowing they will not change.\n\n\n\nDictionaries\nA dictionary in Python is a collection of key-value pairs, similar to how a real dictionary has words (keys) and their meanings (values). Each key in a dictionary must be unique, and you can use it to access its corresponding value. Dictionaries are defined using curly braces {}.\n\nstudent_data = {  \n    \"name\": \"Alex Johnson\",  \n    \"age\": 20,  \n    \"grade\": 88.5,  \n    \"major\": \"Computer Science\"  \n}  \nstudent_data  \n\n{'name': 'Alex Johnson', 'age': 20, 'grade': 88.5, 'major': 'Computer Science'}\n\n\nIn this example, we have a dictionary called student_data that stores various pieces of information about a student’s academic details.\n\nUsing Dictionaries:\n1. Accessing Values: You can retrieve a value using its corresponding key.\n\ncurrent_grade = student_data[\"grade\"]  \ncurrent_grade  \n\n88.5\n\n\n2. Adding or Modifying Values: You can easily add new key-value pairs or modify existing ones:\n\n#Modify Existing one\nstudent_data[\"grade\"] = 92.0  \nstudent_data  \n\n{'name': 'Alex Johnson', 'age': 20, 'grade': 92.0, 'major': 'Computer Science'}\n\n\n\n#Adding new key-value pair\nstudent_data[\"attendance\"] = 95  \nstudent_data  \n\n{'name': 'Alex Johnson',\n 'age': 20,\n 'grade': 92.0,\n 'major': 'Computer Science',\n 'attendance': 95}\n\n\n3. Removing Key-Value Pairs: You can remove a key-value pair using the del statement:\n\ndel student_data[\"major\"]  \nstudent_data  \n\n{'name': 'Alex Johnson', 'age': 20, 'grade': 92.0, 'attendance': 95}\n\n\n\n\n\nExercise 3\n\nCreate a dictionary named countries with these key-value pairs:\n\n\n“United States” : “English”\n“Mexico” : “Spanish”\n“France” : “French”\n“Canada” : “English and French”\n\n\nAdd a new entry to the dictionary: “Brazil” : “Portuguese”\nRemove the key “France” and its value using the del statement.\nPrint the updated dictionary every time.\n\n\ncountries = {\n    \"United States\": \"English\",\n    \"Mexico\": \"Spanish\",\n    \"France\": \"French\",\n    \"Canada\": \"English and French\"\n}\n\nprint(countries)\n\n# Add Brazil\ncountries[\"Brazil\"] = \"Portuguese\"\nprint(countries)\n\n# Remove France using del\ndel countries[\"France\"]\n\nprint(countries)\n\n{'United States': 'English', 'Mexico': 'Spanish', 'France': 'French', 'Canada': 'English and French'}\n{'United States': 'English', 'Mexico': 'Spanish', 'France': 'French', 'Canada': 'English and French', 'Brazil': 'Portuguese'}\n{'United States': 'English', 'Mexico': 'Spanish', 'Canada': 'English and French', 'Brazil': 'Portuguese'}\n\n\n\nChoosing the Right Data Structure\nSelecting the appropriate data structure is crucial. Here’s a quick guide:\n\nUse Lists when you need to store a collection of items that you might want to change or add to, like student grades over multiple subjects or assignments.\nUse Tuples for fixed data points that won’t change, such as geographic coordinates of research locations.\nUse Dictionaries when you need to associate related information together, such as all academic details for a specific student.\n\nChoosing the right data structure will make your data management more efficient and your code easier to understand."
  },
  {
    "objectID": "tuesday/day2_morning_completed.html#control-structures",
    "href": "tuesday/day2_morning_completed.html#control-structures",
    "title": "Introductory Programming with Python",
    "section": "Control Structures",
    "text": "Control Structures\nControl structures are essential programming constructs that allow us to dictate the flow of our program. In Python, the most commonly used control structures include loops (for and while) and conditionals (if and else). These structures enable us to repeat actions, make decisions based on conditions, and manage how we process data.\n\nConditionals\nConditionals allow us to execute certain blocks of code based on specific conditions. This means that our program can make decisions and act differently depending on the situation. The most common conditional statements in Python are if, elif, and else.\n\nBasic Structure of Conditionals:\nHere’s a simple structure for using conditionals:\nif condition: # Code to execute if the condition is true elif another_condition: # Code to execute if the first condition is false and this one is true else: # Code to execute if both conditions are false\n\n\nComparison Operators\nComparison operators allow us to compare two values. Here are the most commonly used comparison operators in Python:\n==: Equal to (checks if two values are the same) !=: Not equal to (checks if two values are different) &gt;: Greater than (checks if the left value is larger than the right) &lt;: Less than (checks if the left value is smaller than the right) &gt;=: Greater than or equal to (checks if the left value is larger than or equal to the right) &lt;=: Less than or equal to (checks if the left value is smaller than or equal to the right)\nLet’s say we want to categorize towns based on their population size:\n\npopulation = 20000\n\nif population &lt; 5000:\n    print(\"Small town\")\nelif 5000 &lt;= population &lt;= 20000:\n    print(\"Medium-sized town\")\nelse:\n    print(\"Large town\")\n\nMedium-sized town\n\n\nIn this example:\n\nIf the population is less than 5,000, it prints “Small town.”\nIf the population is between 5,000 and 20,000 (inclusive), it prints “Medium-sized town.”\nIf the population is over 20,000, it prints “Large town.”\n\n\n\nLogical Operators\nLogical operators allow us to combine multiple conditions. The most commonly used logical operators are:\n\nand: Returns True if both conditions are true.\nor: Returns True if at least one condition is true.\nnot: Reverses the truth value (makes True become False and vice versa).\n\nLet’s say we want to check if someone’s annual income falls within the middle-income bracket:\n\nannual_income = 45000\n\nif annual_income &gt;= 30000 and annual_income &lt;= 70000:\n    print(\"Middle-income bracket\")\nelse:\n    print(\"Outside middle-income bracket\")\n\nMiddle-income bracket\n\n\nIn this example:\n\nThe condition annual_income &gt;= 30000 and annual_income &lt;= 70000 checks if the income is between 30,000 and 70,000 inclusive.\nIf both are true, it prints “Middle-income bracket.”\n\n\n\n\nLoops\nLoops allow us to repeat a block of code multiple times. This is especially useful when we have to process a collection of items, like a list of temperature readings or salinity measurements. The two primary types of loops in Python are for loops and while loops.\n\nFor Loops:\nA for loop is used to iterate over a sequence (like a list or a tuple). Here’s the basic structure:\nfor item in sequence: # Code to execute for each item\nLet’s say we want to print out each survey response score from a list:\n\nsurvey_scores = [3, 4, 5, 2, 4]\n\nfor score in survey_scores:\n    print(f\"Survey score: {score} out of 5\")\nscore\n\nSurvey score: 3 out of 5\nSurvey score: 4 out of 5\nSurvey score: 5 out of 5\nSurvey score: 2 out of 5\nSurvey score: 4 out of 5\n\n\n4\n\n\nIn this example, the loop goes through each item in the survey_scores list and prints it.\nFor loops are useful for analyzing data, such as calculating the average monthly income from several months:\n\nmonthly_incomes = [3000, 3200, 3100, 2900, 4000, 3500, 2500, 2900, 3050, 3200, 3500, 2950]\ntotal_income = 0\n\nfor income in monthly_incomes:\n    total_income += income\n\naverage_income = total_income / len(monthly_incomes)\nprint(f\"Average Monthly Income: ${average_income:.2f}\")\n\nAverage Monthly Income: $3150.00\n\n\nIn this case, the loop adds up all the monthly incomes and then finds the average by dividing by the number of months.\n\n\n\nExercise 4\n\nYou are given a list named populations that contains population numbers (in thousands).\nUse a for loop to add all the population numbers together and store the total in a variable called total_population.\nCalculate the average population by dividing the total population.\nPrint the average population rounded to the nearest whole number.\n\n\npopulations = [2731, 631, 1135, 934, 1705]\n\ntotal_population = 0\n\nfor pop in populations:\n    total_population += pop\n\naverage_population = total_population / len(populations)\n\nprint(\"Average population (in thousands):\", round(average_population))\n\nAverage population (in thousands): 1427\n\n\n\nWhile Loops\nA while loop continues to execute as long as a specified condition is true. The basic structure looks like this:\nwhile condition: # Code to execute while the condition is true\nLet’s say we want to keep recording monthly expenses until we have data for five months:\n\nmonthly_expenses = []\nmax_months = 5\n\nwhile len(monthly_expenses) &lt; max_months:\n    new_expense = float(input(\"Enter monthly expense amount: \"))\n    monthly_expenses.append(new_expense)\n\nprint(\"Monthly expenses collected:\", monthly_expenses)\n\n\n---------------------------------------------------------------------------\nStdinNotImplementedError                  Traceback (most recent call last)\nCell In[80], line 5\n      2 max_months = 5\n      4 while len(monthly_expenses) &lt; max_months:\n----&gt; 5     new_expense = float(input(\"Enter monthly expense amount: \"))\n      6     monthly_expenses.append(new_expense)\n      8 print(\"Monthly expenses collected:\", monthly_expenses)\n\nFile /usr/lib/python3.13/site-packages/ipykernel/kernelbase.py:1281, in Kernel.raw_input(self, prompt)\n   1279 if not self._allow_stdin:\n   1280     msg = \"raw_input was called, but this frontend does not support input requests.\"\n-&gt; 1281     raise StdinNotImplementedError(msg)\n   1282 return self._input_request(\n   1283     str(prompt),\n   1284     self._parent_ident[\"shell\"],\n   1285     self.get_parent(\"shell\"),\n   1286     password=False,\n   1287 )\n\nStdinNotImplementedError: raw_input was called, but this frontend does not support input requests.\n\n\n\nIn this example, the loop keeps asking for monthly expenses until it has collected five amounts.\nWhile loops are useful for continuous data collection, like tracking monthly donations until reaching a target amount:\n\ndonations = 0\n\nwhile donations &lt; 5000:\n    donations += 500\n    print(f\"Total Donations Collected: ${donations}\")\n\nTotal Donations Collected: $500\nTotal Donations Collected: $1000\nTotal Donations Collected: $1500\nTotal Donations Collected: $2000\nTotal Donations Collected: $2500\nTotal Donations Collected: $3000\nTotal Donations Collected: $3500\nTotal Donations Collected: $4000\nTotal Donations Collected: $4500\nTotal Donations Collected: $5000\n\n\n\n\n\nCombining Loops and Conditionals\nOften, we will need to use both loops and conditionals together to process data effectively. For example, you might want to analyze temperature readings and categorize them within a loop.\nLet’s categorize a list of temperature readings as “Cold,” “Warm,” or “Hot”:\n\ntemperature_readings = [10.0, 20.5, 25.0, 30.5]\n\nfor temperature in temperature_readings:\n    if temperature &lt; 15:\n        print(f\"Temperature {temperature} C: Cold\")\n    elif 15 &lt;= temperature &lt;=25:\n        print(f\"Temperature {temperature} C: Warm\")\n    else: \n        print(f\"Temperature {temperature} C: Hot\")\n\nTemperature 10.0 C: Cold\nTemperature 20.5 C: Warm\nTemperature 25.0 C: Warm\nTemperature 30.5 C: Hot\n\n\nIn this example, the loop goes through each temperature reading, and the conditional statements categorize each temperature accordingly.\nNow, let’s say we want to use a loop to analyze data stored in a dictionary. We have a dictionary of historical events and the years they happened. Using a for loop, we can go through each event and year, and use a control structure like an if statement to check whether the event happened before or after 1900.\n\nevents = {\n    \"Signing of the Magna Carta\": 1215,\n    \"French Revolution\": 1789,\n    \"Moon Landing\": 1969,\n    \"Canadian Confederation\": 1867,\n    \"Fall of the Berlin Wall\": 1989\n}\n\nfor event, year in events.items():\n    print(event)\n    \n    if year &lt; 1900:\n        print(\"This event happened before 1900.\\n\")\n    else:\n        print(\"This event happened in or after 1900.\\n\")\n\nSigning of the Magna Carta\nThis event happened before 1900.\n\nFrench Revolution\nThis event happened before 1900.\n\nMoon Landing\nThis event happened in or after 1900.\n\nCanadian Confederation\nThis event happened before 1900.\n\nFall of the Berlin Wall\nThis event happened in or after 1900.\n\n\n\n\n\nExercise 5\nYou are given a dictionary of universities worldwide with their average graduation rates (in percentages):\nuniversities = { “Harvard University”: 98,\n\"University of Oxford\": 92,\n\n\"Stanford University\": 94,\n\n\"Massachusetts Institute of Technology (MIT)\": 92,\n\n\"University of Cambridge\": 93,\n\n\"University of Tokyo\": 70,\n\n\"University of Melbourne\": 79,\n\n\"University of Cape Town\": 68,\n\n\"University of São Paulo\": 65,\n\n\"National University of Singapore\": 80\n}\nTask:\n\nLoop through each university and its graduation rate.\nPrint the university name and its graduation rate.\nUse conditional statements to classify the graduation rate:\n\n90% or above: print “Excellent graduation rate”.\nBetween 75% and 89% (inclusive): print “Good graduation rate”.\nBelow 75%: print “Needs improvement”.\n\n\n\nuniversities = {\n    \"Harvard University\": 98,\n    \"University of Oxford\": 92,\n    \"Stanford University\": 94,\n    \"Massachusetts Institute of Technology (MIT)\": 92,\n    \"University of Cambridge\": 93,\n    \"University of Tokyo\": 70,\n    \"University of Melbourne\": 79,\n    \"University of Cape Town\": 68,\n    \"University of São Paulo\": 65,\n    \"National University of Singapore\": 80\n}\n\nfor university, rate in universities.items():\n    print(university + \" has a graduation rate of \" + str(rate) + \"%.\")\n    \n    if rate &gt;= 90:\n        print(\"Excellent graduation rate\\n\")\n    elif 75 &lt;= rate &lt; 90:\n        print(\"Good graduation rate\\n\")\n    else:\n        print(\"Needs improvement\\n\")\n\nHarvard University has a graduation rate of 98%.\nExcellent graduation rate\n\nUniversity of Oxford has a graduation rate of 92%.\nExcellent graduation rate\n\nStanford University has a graduation rate of 94%.\nExcellent graduation rate\n\nMassachusetts Institute of Technology (MIT) has a graduation rate of 92%.\nExcellent graduation rate\n\nUniversity of Cambridge has a graduation rate of 93%.\nExcellent graduation rate\n\nUniversity of Tokyo has a graduation rate of 70%.\nNeeds improvement\n\nUniversity of Melbourne has a graduation rate of 79%.\nGood graduation rate\n\nUniversity of Cape Town has a graduation rate of 68%.\nNeeds improvement\n\nUniversity of São Paulo has a graduation rate of 65%.\nNeeds improvement\n\nNational University of Singapore has a graduation rate of 80%.\nGood graduation rate"
  }
]
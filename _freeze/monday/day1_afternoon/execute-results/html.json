{
  "hash": "da210bc0a2497961259226605907261b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Introduction to Python for Digital Humanities\njupyter: python3\n---\n\nThe Digital Humanities (DH) is an interdisciplinary field that brings together computational tools and methods with traditional disciplines in the humanities, such as history, literature, art history, linguistics, philosophy, and cultural studies. As the volume of digital cultural content grows—such as digitized manuscripts, historical records, social media posts, and multimedia archives—the need to process, analyze, and interpret these materials using digital tools becomes increasingly important.\n\n### Why Use Python in the Digital Humanities?\n\nPython has emerged as a key language in DH because it is:\n\n- **Easy to Read and Write:** Python’s clean syntax makes it approachable, especially for scholars without a computer science background.\n- **Widely Supported:** Python has a vibrant global community and extensive online documentation, tutorials, and forums.\n- **Rich in Libraries:** There are many ready-to-use libraries for working with text, data, images, sound, and even geographic information.\n- **Flexible and Powerful:** Python can be used for small tasks like file renaming, or large-scale tasks like building full text analysis pipelines or interactive web applications.\n- **Interoperable:** Python can work with many different file formats (e.g., CSV, XML, JSON, PDF, images) and integrate with other tools commonly used in humanities research.\n\n### Practical Applications of Python in DH\n\nUsing Python, digital humanists can:\n\n- **Analyze Large Text Corpora:** Quickly process thousands of pages to extract keywords, count word frequencies, detect sentiment, or classify genres.\n- **Explore Historical Patterns:** Visualize trends over time using data from newspapers, census records, or personal letters.\n- **Build Digital Exhibits:** Combine historical images, audio clips, and data visualizations in an interactive website.\n- **Transcribe and Clean Data:** Automate OCR cleanup, remove metadata noise, or reformat archival information.\n- **Perform Network Analysis:** Study connections between people, places, or concepts across time using network graphs.\n- **Map Cultural Content:** Use Python’s geospatial libraries to create maps that show the spread of artistic movements, migration patterns, or historical events.\n\n### Real-World Examples:\n\n- **Text Mining:** Identify recurring phrases and topics in a century's worth of digitized books.\n- **Social Media Analysis:** Study public sentiment and discourse during key cultural or political events.\n- **Metadata Curation:** Automatically extract, clean, and organize metadata from thousands of image or document files.\n- **Historical Visualization:** Animate the rise and fall of empires using historical timelines and geographic data.\n- **Interactive Archives:** Create searchable digital editions of rare manuscripts using Python web frameworks.\n\nBy learning Python, researchers in the humanities gain a set of tools to extend their traditional methods, handle complex datasets, and share their work in innovative and engaging ways.\n\n\n## Introduction to JupyterLab\nJupyterLab is an interactive computing environment that allows you to create and share documents containing live code, equations, visualizations, and narrative text. It is commonly used in data science, research, and education, especially for projects in the Digital Humanities, because of its flexibility and ease of use. JupyterLab is essentially an upgrade of Jupyter Notebooks, providing a more modular and feature-rich interface.\n\n### Key Features of JupyterLab:\n- **Code cells:** These are cells where you write and execute code.\n- **Markdown cells:** These cells are used for explanatory text, formatted using Markdown.\n- **Rich outputs:** Visualizations, graphs, images, and other media can be displayed inline within the notebook.\n- **File management:** JupyterLab has a built-in file browser that allows you to organize and manage notebooks, text files, images, and other resources.\n\n### How to Add Cells in JupyterLab\nIn JupyterLab, cells are the building blocks of your notebook. You can add, delete, and modify cells to create a flow between code execution and explanatory text.\n\n#### Adding Cells:\n1. **Via Menu:** Navigate to the top menu: *Insert → Insert Cell Below or Insert → Insert Cell Above.*\n\n2. **Keyboard Shortcuts:** *Press B* to insert a cell below the current one or *A* to insert a cell above.\n\n3. **Clicking Buttons:** Use the \"+\" button in the toolbar to insert new cells.\n\n#### Switching Between Cell Types (Code and Markdown):\nYou can switch between code cells and markdown cells to organize your content effectively.\n\n1. **To Change a Cell Type to Code:**\n\n-  Select the cell and *press Y*.\n- Alternatively, click on the Cell Type dropdown menu in the toolbar (where \"Markdown\" is by default) and select Code.\n\n2. **To Change a Cell Type to Markdown:**\n\n- Select the cell and *press M*.\n- Alternatively, use the Cell Type dropdown and select Markdown.\n\nThis allows you to seamlessly switch between running code and writing descriptive text.\n\n#### Running and Stopping Cells\nCells in JupyterLab can either be run (executed) or stopped, depending on whether you want to see the result of the code.\n\n1. **Running Cells:**\nTo execute a cell, you can:\n\n- Windows/Linux: Press *Shift + Enter* to run the current cell and move to the next.\n\n- Mac: Press *Shift + Enter* to run the current cell and move to the next. You can also use *command + Enter* to run the cell and stay in that cell. \n\n- Alternatively, click the *Run* button in the toolbar.\n\n2. **Stopping a Cell:**\nIf you want to stop the execution of a cell:\n\n- Navigate to *Kernel → Interrupt* in the top menu or use the Stop button in the toolbar.\n\n- Alternatively, use the keyboard shortcut *I* twice (press I quickly two times) to interrupt the current execution.\n\n### The Kernel in JupyterLab\nThe kernel is the engine behind your notebook, it runs your Python code and remembers what you’ve done.\n\nWhen you press *Shift + Enter* to run a cell, the kernel executes that code and gives you a result (a number, a list, a graph, etc.).\n\n#### Understanding [ ], [*], and [1] in Jupyter Cells\nEvery time you run a code cell, you’ll see a number appear inside square brackets next to the cell, like this:\n\n::: {#e452ea84 .cell execution_count=1}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\nHere’s what those brackets mean:\n\n**[ ]** — The cell has not been run yet.\n\n**[*]** — The code is currently running (kernel is busy).\n\n**[1], [2], ...** — The number shows the order in which you ran the cells.\n\nFor example:\n\nIf you see [5] next to a cell, it means this was the fifth cell you ran.\n\nIf a cell is stuck on [*], it might be taking a long time or be stuck — you can stop it using Kernel → Interrupt.\n\n#### Common Kernel Actions:\n1. **Run code:** Shift + Enter\n2. **Interrupt kernel:** Stop a running cell (especially useful if stuck on [*])\n3. **Restart kernel:** Clears everything the kernel remembers (variables, imports, etc.)\n\nUse Kernel → Restart if things get messy or confusing — then rerun your cells from the top to start fresh.\n\n## Built-in Functions and Documentation\nPython provides a wide range of built-in functions—these are standard, preloaded tools that help with common tasks. They require no additional libraries or installations and are available immediately when you run Python.\n\n### What Are Built-in Functions?\n\nA built-in function is a function that is always available in Python. These are designed to simplify common programming tasks. For instance, rather than writing your own code to calculate the length of a string, you can use len().\n\nBuilt-in functions improve productivity and reduce the need for writing code from scratch for basic operations.\n\n### Common Built-in Functions and What They Do:\n\n- **print()**: Displays text or variable output.\n- **len()**: Returns the number of items in an object (string, list, etc.).\n- **type()**: Returns the data type of a variable (e.g., int, str).\n- **int()**, **float()**, **str()**: Convert between data types.\n- **range()**: Produces a sequence of numbers, often used in loops.\n- **sum()**: Adds numbers in a list or iterable.\n- **sorted()**: Returns a new list containing all items from the iterable in ascending order.\n- **max()** / **min()**: Finds the largest or smallest value in a dataset.\n\n::: {#a62e7757 .cell execution_count=2}\n``` {.python .cell-code}\n# Example 1: Basic text output\n#Your code goes here\n\n# Example 2: Working with a string\n#Your code goes here\n\n# Example 3: Check data type\n#Your code goes here\n\n# Example 4: Sorting a list\n#Your code goes here\n\n# Example 5: Using range and sum\n#Your code goes here\n```\n:::\n\n\n### Exploring Python Documentation\n\nLearning how to explore the documentation is key to becoming self-sufficient in Python.\n\n**Python provides tools for this:**\n- help() function\n- The ? syntax in Jupyter Notebooks\n\n::: {#afb0fb30 .cell execution_count=3}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\nThis gives detailed information about how to work with strings.\n\n::: {#34f1d9c9 .cell execution_count=4}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\nThis brings up a quick help popup describing the str class.\n\nYou can also combine help with other functions:\n\n::: {#a2cce8ee .cell execution_count=5}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\nThis shows how the len() function works and what types it supports.\n\n## Libraries and Modules\nPython's strength lies in its standard library and external packages—collections of modules that offer specialized functionality. A module is simply a file containing Python definitions and statements. A library is a collection of modules that can be imported and used in your programs.\n\n### Why Libraries Matter:\n\nThey save time and provide tested, optimized tools for:\n- Text processing\n- Data handling\n- Visualization\n- Machine learning\n- File and network operations\n\n### Importing Modules\nTo use a module, you import it into your Python script:\n\n::: {#0e8df483 .cell execution_count=6}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\nYou can also import specific functions or classes:\n\n::: {#f3e01d8f .cell execution_count=7}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\nOr give a library module an alias:\n\n::: {#ed7507b8 .cell execution_count=8}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\n### Built-in Python Libraries\nPython comes with a rich standard library — a collection of modules and packages that are bundled with Python itself. This means you don’t need to install anything extra to start using them. They’re always available whenever you run Python, making it super convenient to perform many common programming tasks right out of the box.\n\n#### *random* : Generate random numbers\n\nUseful for creating random data, games, simulations, or selecting random elements.\n\n::: {#b31b4aa6 .cell execution_count=9}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\n#### *datetime* — Work with dates and times\nEasily get the current date/time or perform date calculations.\n\n::: {#2adffb5e .cell execution_count=10}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\n#### *os* — Interact with your computer’s operating system\nGet info about files, directories, environment variables, or execute system commands.\n\n::: {#5ec2ca29 .cell execution_count=11}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\n### External Libraries\nWhile Python’s built-in libraries cover a lot, many advanced tasks require specialized tools, this is where external libraries come in. These are packages developed by the Python community (or companies) and shared through the Python Package Index (PyPI). You usually install them using the package manager *pip*.\n\n#### What Are External Libraries?\n- They extend Python’s capabilities beyond the standard library.\n- Provide tools for data science, machine learning, web development, image processing, automation, and much more.\n- They often come with many modules and sub-packages bundled together, making them powerful libraries.\n\n#### Installing External Libraries\nNormally, you install external libraries using the command line:\n\npip install library-name\n\nFor example:\n\npip install numpy\npip install pandas\npip install matplotlib\n\nMost popular external libraries used for data science and scientific computing come pre-installed in JupyterLab environments such as:\n- Anaconda distribution (a popular Python distribution for data science)\n- Cloud platforms like Google Colab\n- Many managed JupyterHub setups\n\nThis means when you open a notebook in JupyterLab, you can often import and use libraries like *numpy*, *pandas*, and *matplotlib* immediately, no extra installation required.\n\nLet's see some examples of these libraries:\n\n#### *numpy* — Fast numerical computing\nProvides powerful arrays and mathematical functions.\n\n::: {#94b3128b .cell execution_count=12}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\n#### *pandas* — Data manipulation and analysis\nMakes working with tabular data easy.\n\n::: {#e7e4c201 .cell execution_count=13}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\n#### *matplotlib* — Data visualization\nCreate charts and graphs.\n\n::: {#a7761618 .cell execution_count=14}\n``` {.python .cell-code}\n#Your code goes here\n```\n:::\n\n\n",
    "supporting": [
      "day1_afternoon_files"
    ],
    "filters": [],
    "includes": {}
  }
}